搭建SERVICES教学环境

第一台虚拟机,一般作为服务端 ,虚拟机A

真机 快速产生一台虚拟机clone-vm7

[root@room9pc01 ~]# clone-vm7
Enter VM number: 5

1.将虚拟机的名字修改为A
2.以root用户登陆虚拟机A,密码为123456

虚拟机A要求:
3.配置永久的主机名:svr7.tedu.cn
[root@localhost ~]# echo svr7.tedu.cn  > /etc/hostname
[root@localhost ~]# hostname svr7.tedu.cn

4.配置eth0网卡 永久的IP地址: 192.168.4.7/24

5.检测防火墙是否开启,关闭防护墙
# systemctl status firewalld

6.检测SELinux是否开启,关闭SELinux
# getenforce 
Disabled



###############################################################
为虚拟机A搭建Yum仓库
[root@room9pc01 ~]# ssh -X root@192.168.4.7
root@192.168.4.7's password: 
Last login: Thu Mar 29 09:09:37 2018 from 192.168.4.254
[root@svr7 ~]# 
真机作为Yum服务端
1.利用FTP共享光盘所有内容
[root@room9pc01 ~]# rpm -q vsftpd            #安装软件包
vsftpd-3.0.2-22.el7.x86_64

[root@room9pc01 ~]# systemctl status vsftpd  #查看服务是否开启

默认共享的路径:/var/ftp

# firefox ftp://192.168.4.254/rhel7

# mkdir /var/ftp/rhel7
# mount /var/lib/libvirt/images/iso/rhel-server-7.4-x86_64-dvd.iso   /var/ftp/rhel7

[root@room9pc01 ~]# vim /etc/fstab 
/var/lib/libvirt/images/iso/rhel-server-7.4-x86_64-dvd.iso  /var/ftp/rhel7 iso9660 defaults 0 0

虚拟机A作为Yum客户端
[root@svr7 ~]# vim /etc/yum.repos.d/dvd.repo
[rhel7]
name=dvd
baseurl=ftp://192.168.4.254/rhel7
enabled=1
gpgcheck=0
[root@svr7 ~]# yum -y install mariadb-server

################################################################
扩展的几个应用


[root@svr7 ~]# man hier


常见一级目录的用途
主要用途
  /boot         存放系统引导必需的文件,包括内核、启动配置
  /bin、/sbin   存放各种命令程序
  /dev          存放硬盘、键盘、鼠标、光驱等各种设备文件
  /etc          存放Linux系统及各种程序的配置文件
  /root、/home/ 用户名 分别是管理员root、普通用户的默认家目录
  /var          存放日志文件、邮箱目录等经常变化的文件
  /proc         存放内存中的映射数据,不占用磁盘
  /tmp          存放系统运行过程中使用的一些临时文件


#################################################
虚拟机A操作
 权限的数值表示,  利用 4  2  1 三个数字表示 r  w  x

 [root@svr7 ~]# mkdir /nsd01
 [root@svr7 ~]# ls -ld /nsd01

 [root@svr7 ~]# chmod 700 /nsd01
 [root@svr7 ~]# ls -ld /nsd01

 [root@svr7 ~]# chmod 007 /nsd01
 [root@svr7 ~]# ls -ld /nsd01

 [root@svr7 ~]# chmod 750 /nsd01
 [root@svr7 ~]# ls -ld /nsd01

#####################################################

历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !str:执行最近一次以str开头的历史命令


• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000               //默认记录1000条

[root@svr7 ~]# history 

[root@svr7 ~]# history -c

[root@svr7 ~]# cat  /etc/redhat-release

[root@svr7 ~]# history

[root@svr7 ~]# !cat

###########################################################

• du,统计文件的占用空间
– du [选项]... [目录或文件]...

– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du -sh /root/  /etc/  /home/
1.5G	/root/
43M	/etc/
12K	/home/


zip归档工具,跨平台的压缩工具

• 归档+压缩操作
– zip [-r]  备份文件.zip  被归档的文档...


• 释放归档+解压操作
– unzip  备份文件.zip  [-d 目标文件夹]


[root@svr7 ~]# zip -r /opt/test.zip /home/ /mnt/


[root@svr7 ~]# mkdir /nsd
[root@svr7 ~]# unzip /opt/test.zip -d /nsd
[root@svr7 ~]# ls /nsd

##################################################################

  5:显示配置文件的帮助信息


[root@svr7 ~]# man 5 passwd


##############################################################
实用小命令工具
• ln,创建软连接
– 软连接 --> 原始文档 --> i节点 --> 文档数据
– ln -s 原始文件或目录 软连接文件
若原始文件或目录被删除,连接文件将失效
软连接可存放在不同分区/文件系统


• ln,创建硬连接
– 硬连接 --> i节点 --> 文档数据
– ln 原始文件 硬连接文件
若原始文件被删除,连接文件仍可用
硬连接与原始文件必须在同一分区/文件系统


制作快捷方式
  格式:  ln  -s    /路径/源文件     /路径/快捷方式名称

[root@svr7 ~]# cat /etc/redhat-release 

[root@svr7 ~]# ln -s /etc/redhat-release  /abc
[root@svr7 ~]# ls -l /abc 

[root@svr7 ~]# cat /abc


  i节点: 硬盘上文件唯一的编号


################################################################
 只有硬连接,不会产生新的文件
[root@svr7 ~]# rm -rf /opt/*
[root@svr7 ~]# echo 123 > /opt/A
[root@svr7 ~]# cat /opt/A

[root@svr7 ~]# ln -s /opt/A /opt/A1      #制作软连接
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# ls -l /opt/A1

[root@svr7 ~]# ln /opt/A /opt/A2         #制作硬连接
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/A2

[root@svr7 ~]# cp /opt/A /opt/A3
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/A3

[root@svr7 ~]# ls -i /opt       #查看文件 i节点 编号

##################################################################
自定义yum仓库

1.有光盘之外的包
2.将真机tools文件夹,传递到虚拟机A根目录下
 真机上实现
 # scp   -r   /root/桌面/tools   root@192.168.4.7:/

3.到虚拟机A验证
 # ls /
 # ls /tools

4.生成仓库数据文件
[root@svr7 ~]# createrepo /tools/other/
[root@svr7 ~]# ls /tools/other/

5.修改配置文件/etc/yum.repos.d/dvd.repo
[root@svr7 ~]# vim /etc/yum.repos.d/dvd.repo 
[rhel7]
name=dvd
baseurl=ftp://192.168.4.254/rhel7
enabled=1
gpgcheck=0

[myrpm]
name=myrpm
baseurl=file:///tools/other
enabled=1
gpgcheck=0

[root@svr7 ~]#  yum repolist

##############################################################
 显示已安装软件包的安装清单

 rpm  -ql  软件名 

##############################################################

vim编辑技巧

 命令模式操作  

[root@svr7 ~]# head -6 /etc/passwd > /opt/abc.txt
[root@svr7 ~]# vim /opt/abc.txt 
光标跳转
	Home键 或 ^	 跳转到行首
	End键 或“$”键 	跳转到行尾
	1G 或 gg 		跳转到文件的首行
	G 			跳转到文件的末尾行

复制/粘贴/删除
	yy、#yy 		复制光标处的一行、#行
	粘贴 p 		粘贴到光标处之后、之前
	x 或 Delete键   删除光标处的单个字符
	dd、#dd 		删除光标处的一行、#行
	d^ 			从光标处之前删除至行首
	d$ 			从光标处删除到行尾
	C(大写的) 	从光标处删除到行尾,并且进入输入模式


查找/撤销/保存
	/word 	  向后查找字符串“word”
	n、N 	  跳至后/前一个结果
	u 		  撤销最近的一次操作
	Ctrl + r   取消前一次撤销操作
	ZZ 		  保存修改并退出


末行模式操作

	:q! 					放弃已有更改后强制退出
	:wq 或 :x 			保存已有修改后退出
	:r /etc/filesystems 	读入其他文件内容

[root@svr7 ~]# echo 123 > /opt/1.txt
[root@svr7 ~]# echo abc > /opt/2.txt
[root@svr7 ~]# vim /opt/2.txt

         	:r /etc/redhat-release 	#读入其他文件内容
         	:r /opt/1.txt 			#读入其他文件内容


字符串替换
	:s/old/new 		替换当前光标所在行第一个“old”
	:s/old/new/g 		替换当前光标所在行所有的“old”
	:n,m s/old/new/g 	替换第n-m行所有的“old”
	:% s/old/new/g 	替换文件内所有的“old

[root@svr7 ~]# head -10 /etc/passwd > /opt/abc.txt
[root@svr7 ~]# vim /opt/abc.txt

	    :s/root/admin/  
	    :s/root/admin/g            
	    :1,8 s/root/admin/g
	    :%s /root/admin/g

开关参数的控制
	:set nu 或 nonu 	显示/不显示行号
	:set ai 或 noai 	启用/关闭自动缩进
	:set hlsearch或nohl   设置高亮/取消高亮

 vim不允许多终端,打开同一个文件
 vim不能创建目录

############################################################
源码编译安装

  rpm包------->rpm  yum----->安装

   源码包------gcc make-------> 可以执行的程序--------->运行安装

• 主要优点
– 获得软件的最新版,及时修复bug
– 软件功能可按需选择/定制,有更多软件可供选择
– 源码包适用各种平台

步骤1:安装gcc 与 make开发工具
[root@svr7 ~]# yum  -y  install  gcc   make

步骤2:tar解包,释放源代码至指定目录
[root@svr7 ~]# tar -xf /tools/inotify-tools-3.13.tar.gz -C /opt/
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# ls /opt/inotify-tools-3.13/

[root@svr7 ~]# cd /opt/inotify-tools-3.13/

步骤3: ./configure 配置,指定安装目录/功能模块等选项
    作用1: 指定安装目录/功能模块等选项
    作用2: 检测本机是否安装gcc与make

[root@svr7 ~]# cd /opt/inotify-tools-3.13/
[root@svr7 inotify-tools-3.13]# ./configure --prefix=/mnt/myrpm

报错提示:没有安装gcc
checking for gcc... no
checking for cc... no
checking for cl.exe... no

步骤4: make 编译,生成可执行的二进制程序文件
[root@svr7 inotify-tools-3.13]# make 
 
步骤5: make install 安装,将编译好的文件复制到安装目录
[root@svr7 inotify-tools-3.13]# make install
[root@svr7 inotify-tools-3.13]# ls /mnt/myrpm/
bin  include  lib  share
################################################################

systemctl控制

[root@svr7 /]# systemctl restart  服务名    #重起服务
[root@svr7 /]# systemctl enable   服务名     #设置服务开机自启动


[root@svr7 /]# systemctl status   服务名     #查看服务当前的状态
[root@svr7 /]# systemctl start    服务名  
[root@svr7 /]# systemctl stop     服务名  
[root@svr7 /]# systemctl disable   服务名   #设置服务开机不再自启动

模式控制

     字符模式: multi-user.target 

     图形模式: graphical.target

• 切换到文本/图形模式
– systemctl isolate multi-user.target
– systemctl isolate graphical.target

• 查看默认模式
– systemctl get-default
• 设置默认模式
– systemctl set-default multi-user.target
– systemctl set-default graphical.target

[root@svr7 /]# systemctl isolate graphical.target      #当前临时切换
[root@svr7 /]# reboot

[root@svr7 /]# systemctl set-default graphical.target  #修改默认
[root@svr7 /]# systemctl get-default                   #查看默认模式
[root@svr7 /]# reboot 

#################################################################




  曾 晔

   浏览器 http：//172.40.50.113/note
  vncviewer  172.40.50.113:7000

   classroom

提前搭建实验环境：
svr7.tedu.cn ==》 192.168.4.7/24
pc207.tedu.cn ==》 192.168.4.207/24

svr7作为主要的DNS服务器
pc207作为测试用的客户机


  路由器，只认识IP地址，不认识 www.baidu.com



 网站 www.baidu.com 的IP地址在哪里？

 问某个DNS服务器 类似于 114查号台

注册一个域名  zylinux.cn，
获得的权利：
    决定 *.zylinux.cn 的IP地址是多少


   我的Web服务器 放在 某一个电信机房，IP地址  60.72.83.94
添加一个 www.zylinux.cn ==》60.72.83.94



域名注册费用，XXX元/年

360buy.com ==》 jd.com
oicq.com ==》tencent.com

搭建DNS服务器的基本步骤 ——
1. 装包
# yum  -y  install   bind   bind-chroot

2. 配置
主配置文件 /etc/named.conf 【管理哪些区域、地址库文件在哪】
# cat  /etc/named.conf 
options { directory  "/var/named"; };
zone  "tedu.cn"  {
	type  master;           
	file  "tedu.cn.zone";
};
# named-checkconf 		【若配置正确，无任何输出】

地址库（区域数据）文件： /var/named/自定义文件名
# vim  /var/named/tedu.cn.zone
.... // 文件头参考 named.localhost 文件的内容复制过来
@  	NS	svr7.tedu.cn.
www  	A	192.168.4.100
svr7  	A	192.168.4.7
pc207  	A	192.168.4.207

# named-checkzone  tedu.cn   /var/named/tedu.cn.zone
zone tedu.cn/IN: loaded serial 0
OK


chroot 切换根目录（提供一个伪造的根）【笼环境】
==》把 /var/named/chroot/ 目录当成 / 根目录


把192.168.4.7配置为 tedu.cn 区域的DNS服务器
www.tedu.cn  ===》 192.168.4.100
svr7.tedu.cn  ===》 192.168.4.7
pc207.tedu.cn  ===》 192.168.4.207




一个服务器的IP地址，为它注册多个域名


www.tedu.cn
www.tmooc.cn
www.tarena.com.cn
tts8.tmooc.cn
.. ..


3. 起服务（在svr7上，!!! 关闭防火墙）
# systemctl  restart  named

客户机测试（在pc207主机上查询DNS ——
1）为客户机指定默认DNS
# nmcli  con  mod  eth0  ipv4.dns  192.168.4.7
# nmcli  con  up  eth0
2）测试DNS查询结果
# host   www.tedu.cn
www.tedu.cn has address 192.168.4.100
  					//地址库里有记录的可以查到结果
# host wwww.tedu.cn
Host wwww.tedu.cn not found: 3(NXDOMAIN)
  					//地址库里没有记录的查不到结果


互联网网站访问 www.tedu.cn 场景：
1）浏览器（客户机）—— 192.168.4.7
a. 输入 http://www.teud.cn/ 并回车
b. 浏览器向DNS查询“www.tedu.cn 的IP地址是多少？”
c. 封装一个HTTP访问请求发给目标IP地址 192.168.4.100
d. 收到来自网站服务器提供的网页

2）DNS服务器（新网）—— 192.168.4.7
a. 收到来自客户机的查询请求
b. 检查客户机的问题是否属于自己管理的DNS区域（地址库内查找是否有一条 www 的A类型的记录）
c. 告诉客户机 www.tedu.cn 的IP地址（192.168.4.100）

3）网站服务器（达内）—— 192.168.4.100
付费注册DNS域名  —— 让DNS服务器告诉其他任何客户机“www.tedu.cn 的IP地址是 192.168.4.100”

a. 收到来自浏览器提交的HTTP访问请求
b. 由本机的Web服务程序来处理这个HTTP访问请求
c. 按照浏览器的请求提供相应的网页



DNS轮询（负载均衡）—— 比如百度、网易、……
特点：同一个域名 --> 多个IP地址

www.tedu.cn  --> 
192.168.4.100 可以承受 10000个用户同时访问
192.168.4.110  +10000并发负载能力
192.168.4.120  +10000并发负载能力

实现DNS轮询的关键：修改所在地址库的解析记录
www  	A	192.168.4.100
www  	A	192.168.4.110
www  	A	192.168.4.120


泛域名解析 —— 
特点：多个域名（后缀相同） --> 同一个IP地址
www.jd.com
或者 jd.com

3w.jd.com
sanw.jd.com
当用户访问一个域名时，只要后缀是正确的，都能够找到正确的网站

实现泛域名解析的关键：修改所在地址库的解析记录
*  	A	192.168.4.100  
@	A	192.168.4.100	#只输入tedu.cn 就可以访问www.tedu.cn



DNS服务器 ：. 		根域（上级域）

DNS服务器 ：.cn 		一级（上级域）

DNS服务器 svr7：tedu.cn 		二级（上级域）
	www.tedu.cn	192.168.4.100

DNS服务器 pc207：bj.tedu.cn 	三级（下级域）
	www.bj.tedu.cn	1.2.3.4


亲密/疏远：
属于同一个机构管理的上下级区域，一般称为 父子域

子域授权配置关键（修改父区域地址库）：
子域域名.            NS 	子DNS的FQDN.
子DNS的FQDN.  A		子DNS的IP地址


当一台DNS服务器（tedu.cn）收到一个查询非本DNS管辖的域名（www.bj.tedu.cn）的请求时 ——
情况1：未配置子域授权，告诉客户机“not found”
情况2-父子域（递归查询）：配置了子域授权，帮客户机去查询并把结果告诉客户机
情况3-上下级域（迭代查询）：配置了子域授权，不愿意/不方便帮客户机去查询结果，但是会告知客户机应该去问另一个DNS服务器



缓存DNS服务器（比如教学环境CentOS真机 192.168.4.254）
1）能正常上网（至少能查询各种域名）
2）客户机（比如pc207）必须能正常访问本DNS

实现过程 —— 
0）简单准备工作
停用与DNS服务冲突的其他服务（dnsmasq）
# pkill  -9  dnsmasq
1）装包 bind  bind-chroot
2）配置（指向可用的公共DNS服务器地址）
# vim  /etc/named.conf
options {  forwarders {  172.40.1.10;  }; };
3）起服务 named

客户机测试：
# host  www.qq.com   192.168.4.254



今日重点：
1）理解DNS的作用
2）搭建基本的DNS服务器
3）客户机如何使用指定的DNS
4）缓存DNS怎么部署




回顾 ——
1）理解DNS系统的作用
2）学会搭建一台权威DNS服务器
3）学会使用DNS服务器
4）学会搭建一台缓存DNS服务器


1）理解DNS系统的作用
互联网的指路人，提供信息查询“网站域名 --》IP地址”

知道一个www.baidu.com的IP地址
不等于
能访问 www.baidu.com 的网页

FQDN，完全合格的域名 ==》互联网的一个服务器的DNS地址
www.pku.edu.cn
www 站点名（对应一台服务器）
pku.edu.cn 区域名（对应一个公司/单位/机构/组织）


2）学会搭建一台权威DNS服务器
为 tedu.cn 区域提供域名解析（意思：当有其他客户机来问你这台DNS服务器 “以 tedu.cn 结尾的那些域名的IP地址是多少”时，你这台DNS应该能提供正确的答案）
svr7.tedu.cn 的 IP地址是 192.168.4.7
pc207.tedu.cn 的 IP地址是 192.168.4.207
www.tedu.cn 的 IP地址是 192.168.4.100

配置关键：
# vim  /etc/named.conf 	【负责的区域、地址库文件在哪】
options {
	directory  "存放地址库文件的默认目录";
};
zone  "区域1名"  {
	type  master;
	file  "地址库1文件名";
};
zone  "区域2名"  {
	type  master;
	file  "地址库2文件名";
};

# vim  /.../地址库文件名 	【XX站点的IP地址是多少？】
文件头（参考模板文named.localhost件复制）
@		NS	本DNS服务器的FQDN.
站点1名 	A	站点1的IP地址
站点2名 	A	站点2的IP地址
.. ..


3）学会使用DNS服务器
为Linux主机指定默认使用哪一台DNS服务器：
# nmcli  con  mod  "连接名"  ipv4.dns  DNS服务器的IP地址
# nmcli  con  mod  up  "连接名" 		【永久】
# vim  /etc/resolv.conf  	 		【临时】
nameserver  DNS服务器的IP地址
测试DNS服务器时可以手动临时指定使用哪一台DNS服务器：
# host   XX域名    DNS服务器的IP地址

4）学会搭建一台缓存DNS服务器
前提条件：
1）客户机能访问到缓存DNS
2）缓存DNS服务器能够正常访问其他的可用的公共DNS

配置关键：
# vim  /etc/named.conf
options  {
	forwarders { 公共DNS的IP地址; };
};


DNS的子域授权 ——
告诉上一级DNS服务器：
子域叫什么名，负责子域内站点解析的下一级DNS服务器的FQDN.
下一级DNS服务器的FQDN. 的IP地址是多少

对于上一级DNS服务器来说，
如果 子域授权+ 愿意为客户机查询非本机管理的域名 ==》递归（缓存DNS服务器）
如果 子域授权+ 不愿意为客户机查询非本机管理的域名 ==》迭代（有下级子域权威DNS）

recursion yes|no;


DNS地址库的特殊应用 ——

DNS轮询，一个域名解析为多个IP地址
# vim  地址库文件
.. ..
www		A	 IP地址1
www		A	 IP地址2
www		A	 IP地址3

泛域名，多个未知域名解析为同一个IP地址
# vim  地址库文件
.. ..
*		A		IP地址


练习：扩展DNS服务器 svr7的功能
除了负责 tedu.cn 区域以外，
还能够为教学环境的 example.com 提供域名解析服务
实验目标（提供解析结果）：
classroom.example.com ==》172.25.254.254
content.example.com ==》172.25.254.254
server0.example.com ==》172.25.0.11
www0.example.com ==》172.25.0.11
webapp0.example.com ==》172.25.0.11
desktop0.example.com ==》172.25.0.10
smtp0.example.com ==》172.25.0.10

在服务器svr7上：
1）调整主配置
[root@svr7 ~]# vim  /etc/named.conf
options {
        directory  "/var/named";
};
zone  "tedu.cn"  {
        type  master;
        file  "tedu.cn.zone";
};
zone  "example.com"  {
        type  master;
        file  "example.com.zone";
};

2）建地址库
[root@svr7 ~]# cd /var/named/
[root@svr7 named]# cp -p tedu.cn.zone  example.com.zone
[root@svr7 named]# vim example.com.zone 
.. ..
@       NS      svr7.tedu.cn.
classroom 	A  172.25.254.254
content 	A  172.25.254.254
server0 	A  172.25.0.11
www0 		A  172.25.0.11
webapp0 	A  172.25.0.11
desktop0 	A  172.25.0.10
smtp0 		A  172.25.0.10
3）起服务
[root@svr7 named]# systemctl restart named


两个问题：
1）options全局设置只需要一段 
2）为什么 example.com 区域的NS记录还是 svr7.tedu.cn. 【一个DNS服务器管理多个区域时，没必要在每一个区域都注册一个域名】

今日目标：
1）理解分离解析原理，并通过实验验证
2）了解RAID阵列的几种方式和各自的特点
3）学会查看和控制系统的进程信息
4）学会通过日志去了解系统或服务发生的事件


场景1：
www.12306.cn
==》 IP地址1（联通）、IP地址2（移动）、IP地址3（电信）、……


当一个联通宽带用户访问 www.12306.cn 时，面临的问题？
单纯的DNS轮询难以解决

需要DNS更加智能 —— 
1）当联通的客户机来访问www.12306.cn，告诉客户机IP地址1
2）当移动的客户机来访问www.12306.cn，告诉客户机IP地址2
1）当电信的客户机来访问www.12306.cn，告诉客户机IP地址3


智能DNS（Split分离解析）


Content  Delivery Network，内容分发网络
铁道部：负责提供Web网站/数据库内容，假设 2 台
CDN服务商（蓝汛）：负责为铁道部在全国部署200台缓存服务器，由这些缓存服务器面向购票用户
购票用户：===》CDN服务商的缓存服务器

铁道部成本降低
CDN服务商赚钱
用户访问速度块

CDN服务商需要做的事情：
当用户查询www.12306.cn时，把客户机引导到最近/最快的那一台缓存服务器上

配置关键步骤：
1）建立2份地址库
/var/named/tedu.cn.zone.1 【www  ==》192.168.4.100】
/var/named/tedu.cn.zone.2 【www  ==》1.2.3.4】

2）在 /etc/named.conf 创建2个视图
options {
        directory  "/var/named";
};
view  "mylan" {  			//第1个视图设置
        match-clients { 192.168.4.207; 192.168.7.0/24;  };
        zone "tedu.cn" {
                type  master;
                file "tedu.cn.zone.1";
        };
};
view  "other" {  			//第2个视图设置
        match-clients { any;  };
        zone "tedu.cn" {
                type  master;
                file "tedu.cn.zone.2";
        };
}; 



了解RAID阵列的几种方式和各自的特点
RAID —— 把一堆便宜磁盘整合成一块大磁盘
主要实现两个目标
1）提高磁盘读写速度
2）提供硬件备份

RAID阵列实现方式

硬RAID：由RAID控制卡管理阵列
主板-->阵列卡-->磁盘-->操作系统-->数据
软RAID：由操作系统来管理阵列
主板-->磁盘-->操作系统-->RAID软件-->数据

RAID磁盘阵列（Redundant Arrays of Inexpensive Disks：廉价冗余磁盘阵列）
	通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘
	阵列的价值:提升I/O效率、硬件级别的数据冗余
	不同RAID级别的功能、特性各不相同
• RAID 0,条带模式
	同一个文档分散存放在不同磁盘
	并行写入以提高效率
	至少2块磁盘

• RAID 1,镜像模式
	一个文档复制成多份,分别写入不同磁盘
	多份拷贝提高可靠性,效率无提升
	至少2块磁盘

• RAID 0+1/RAID 1+0
	整合RAID 0、RAID 1的优势
	并行存取提高效率、镜像写入提高可靠性
	至少4块磁盘

• RAID5,高性价比模式（）
	相当于RAID0和RAID1的折中方案
	需要至少一块磁盘的容量来存放校验数据（如果数据丢失，校验数据可以根据现有的数据修复丢失的数据）
	至少3块磁盘

• RAID6,高性价比/可靠模式
	相当于扩展的RAID5阵列,提供2份独立校验方案
	需要至少两块磁盘的容量来存放校验数据
	至少4块磁盘




其他好处：
拥有更大容量的磁盘、性价比更高

阵列如何实现（RAID级别）？


500GB X 6块 构建 RAID5 阵列
==》2.5TB

500GB X 6块 构建 RAID6 阵列
==》2TB

500GB X 6块 构建 RAID0 阵列
==》3TB

500GB X 6块 构建 RAID1 阵列
==》500GB

500GB X 6块 构建 RAID10 阵列
==》3块组条带 x2 镜像  1.5TB
==》2块组条带 x3 镜像  1.0TB
  


学会查看和控制系统的进程信息 ——

Process，进程（内存中正在进行的程序）

整个Linux操作系统是由大量的进程（每一个进程都由一个编号PID）一起提供服务的
系统开机 ==》内核 ==》系统管理器（PID 1） ==》其他程序。。。

父进程
子进程

### 查看进程信息 ——
    为了更好的掌握系统的状态
pstree 看进程树

练习：
1）查看Linux系统的整个进程树结构，显示各进程的PID号
# pstree  -p
2）从上述结果中找出sshd进程的PID值
# pstree  -p  |  grep  sshd
3）根据sshd进程的PID值查看进程树，列出各进程的命令行
# pstree  -ap  937

ps，进程快照，用来为系统中所有进程拍照

练习：
1）安装并启用httpd服务
# yum  -y  install  httpd
# systemctl  restart  httpd
2）列出系统中所有的httpd进程，比较每个进程属于哪个用户
# ps  aux | grep  httpd
3）列出系统中所有httpd进程的父进程号，观测差别
# ps  -elf | grep  httpd
4）查看前一步结果中PID编号最小（辈分最大）的httpd进程的进程树
# pstree  -p  9634
5）ps aux 查看所有进程的的pid，cpu，内存使用量
6）ps -ef  查看进程的父进程

关于httpd网站服务器：
第1个httpd进程由root运行，不面向Web用户
第2个及以后的httpd进程是以apache用户身份运行，面向Web用户





知道一个进程的父进程有什么作用？
比如病毒进程
如果一个进程被杀死，这个进程会自动把所有子进程都终止

孤儿进程和僵尸进程

我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。
孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，
那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

任何一个子进程(systemd除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

https://www.cnblogs.com/Anker/p/3271773.html
使用 ps -eo ppid,stat | grep Z  查看存在的僵尸进程





top，查看进程资源占用情况，动态展示（实时录像）
# top
top - 15:53:09 up  6:23,  3 users,  load average: 0.00, 0.01, 0.05
Tasks: 150 total,   2 running, 148 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  2049108 total,  1267212 free,   303156 used,   478740 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  1556160 avail Mem 

排名信息。。。

CPU处理器的平均负载：最近1分钟，5分钟，15分钟
load average: 0.00, 0.01, 0.05
%Cpu(s):   99.7 id 空闲
按数字1切换多核模式

按q键退出


练习：
1）查看当前主机的CPU负载情况
2）查看当前主机开启了多长时间、有几个用户登录、运行的进程数
3）查看当前主机的CPU、内存、交换分区空闲比率
4）观测当前占用CPU资源最多的进程叫什么名


pgrep 检索进程信息
练习：
1）查看用户mike开启的进程名、PID号
# pgrep  -l  -U  mike
2）统计当前主机运行的进程的数量
# pgrep  .  |  wc  -l
3）检查网站服务进程httpd是否已经开启
# pgrep  -l  httpd
4）找出名字为 gdm 的进程的PID号
# pgrep  -x  gdm


pgrep  关键词  ==》只要进程名包括这个关键词，就符合条件
pgrep  -x  关键词  ==》必须进程名等于这个关键词，才符合条件

例如：有2个进程 —— 张三、张三丰
# pgrep  张三
张三的PID
张三丰的PID
# pgrep  -x  张三
张三的PID


2）控制进程
进程前后台调度 ——
测试用的命令工具格：
# sleep  秒数

fg，forground 前台
bg，background 后台
jobs，列出任务
Ctrl  z 暂停当前任务



杀死进程（选择进程不同的死法）——
根据进程的PID号
# kill  PID  .. ..
根据后台进程的任务编号
# kill  %任务编号  .. ..
根据进程的名称
# killall  进程名
根据进程所属的用户（符合XX条件）
# pkill  -U  用户名

!!! 不带信号 -9 表示正常杀死进程
!!! 带信号 -9 表示强制杀死

方法汇总:
1、Ctrl+c 中断当前命令程序
2、kill [-9] PID / kill [-9] %后台任务编号
3、killall [-9] 进程名 / killall [-9] -u 用户名
4、pkill [-9] -U 用户名 / pkill [-9] 关键字





图形桌面下的点杀工具 xkill ——
按 Alt F2 调出运行命令的工具，输入 xkill 并回车








    
练习：进程调度及终止
1）运行“sleep 600”命令
2）另开一个终端，查出sleep程序的PID并杀死
3）运行多个vim程序并分别都放入后台
4）杀死所有vim进程
5）su切换为zhsan用户
6）另开一个终端，强制踢出zhsan用户






今日重点：
1）分离解析的原理
2）RAID磁盘阵列的各个级别的特点
3）查找进程的各种方法
4）杀死进程的各种方法





回顾 ——
DNS智能解析（Split View）
1）主配置文件 /etc/named.conf
view  "类别1"  {
	match-clients  { 第一类客户机地址; .. .. ;  };
	zone  "XX区域名"  {
		type  master;
		file  "/var/named/地址库文件1"
	};
};
view  "类别2"  {
	match-clients  { 第二类客户机地址; .. .. ;  };
	zone  "XX区域名"  {
		type  master;
		file  "/var/named/地址库文件2"
	};
};
view  "默认类别"  {
	match-clients  { any;  };
	zone  "XX区域名"  {
		type  master;
		file  "/var/named/地址库文件n"
	};
};
2）地址库文件
# vim   /var/named/地址库文件1
.. ..
www		A	IP地址1
# vim   /var/named/地址库文件2
.. ..
www		A	IP地址2
# vim   /var/named/地址库文件n
.. ..
www		A	默认IP地址


测试向指定的DNS服务器查询XX域名的IP地址：
# host  XX域名    DNS服务器
或者
# nslookup  XX域名    DNS服务器


常用的公共DNS：
202.106.0.20
114.114.114.114
8.8.8.8 （谷歌）
9.9.9.9 （IBM）
1.1.1.1 （国外X公司）

!!! DNS配置常见问题
1）拼写错误（多使用检查工具）
2）有冲突的服务（pkill  -9  dnsmasq）
3）地址库文件的权限（如果是cp模板文件，别忘了 -p 选项）

RAID磁盘阵列 （多块磁盘 --》一块磁盘）——
RAID0，条带模式，提高速度
RAID1，镜像模式，提高可靠性
RAID10，条带+镜像模式，提高速度和可靠性
RAID5，均衡模式，提高速度/可靠性（性价比更好），使用1块容错盘
RAID6，优化版的RAID5，使用2块容错盘


进程管理 ——
通过查看进程来了解系统的运行状态：
pstree  -ap 或  pstree  PID  	【进程树】
ps  aux 或 ps  -elf  			【用户、%CPU、%MEM等】
top  -d  秒数 				【系统负载、资源占用排名】
pgrep  -l  关键词
pgrep   -U  用户名

控制进程：
cmd  &  将命令进程放入后台运行
Ctrl  z  暂停当前进程并放入后台
jobs  -l 	列出当前用户当前命令行环境的后台任务
fg 	将后台任务恢复到前台运行
bg	激活后台被挂起的任务
Ctrl  c   终止当前进程
kill  -9  PID...
killall  -9  进程名...
killall  -9  -u  用户名
pkill  -9  关键词
pkill  -9  -U  用户名
xkill

man  命令名   ==》 查看命令用法手册页
# man  kilall  
man  配置文件名  ==》 查看配置文件的手册页
# man  named.conf


今日目标 ——
通过网络为一批客户机自动装系统
1）准备装机环境
2）配置PXE装机服务器
3）实现自动应答/无人值守


准备装机环境 —— 
在真机上提供软件安装源 http://192.168.4.254/rh7dvd
1）启用httpd服务
# systemctl  restart  httpd
2）挂载RHEL7的ISO文件到 /var/www/html/rh7dvd
# mkdir -p /var/www/html/rh7dvd
# vim  /etc/fstab
ISO文件的绝对路径	/var/www/html/rh7dvd  iso9660  defaults  0  0
# mount  /var/www/html/rh7dvd
# ls  /var/www/html/rh7dvd/  	//确认目录下有资源
3）检查，确认软件源可访问
浏览器访问 http://192.168.4.254/rh7dvd，可看到软件目录资源


常见问题：执行mount  -a 挂载不成功
原因：同一个镜像挂载到多个位置，如果其中一个位置已经挂载，那么在执行mount  -a时不再挂载新的位置
解决办法：
重起，
或者 mount  挂载点
或者 卸载这个设备的所有挂载点，再重新mount  -a


DHCP服务器，为客户机动态提供IP地址相关参数


一台计算机如何从DHCP服务器获取IP地址
1）客户机 请求，DHCP DISCOVERY
2）服务器 提供，DHCP OFFER
3）客户机 选择，DHCP REQUEST 
4）服务器 确认，DHCP ACK


快速搭建DHCP服务器（svr7） ——
1）装包 dhcp
# yum  -y  install  dhcp
2）配置
# vim  /etc/dhcp/dhcpd.conf
subnet  192.168.4.0  netmask  255.255.255.0 {
	range  192.168.4.10  192.168.4.200;
	next-server  192.168.4.7; 	//PXE装机服务器地址
	filename  "pxelinux.0"; 		//启动文件
}
3）起服务 dhcpd
# systemctl  restart  dhcpd
4）确认监听状态
# netstat   -anptu  |  grep  :67
5）在客户机pc207上测试
# dhclient  -d  eth0

选项含义：
-a，所有连接
-n，以数字方式显示地址和端口
-p，列出对应的进程和PID
-t，列出TCP类型的连接
-u，列出UDP类型的连接



DHCP服务监听端口：UDP 67




BOOTROM 启动芯片


PXE 应用：
方式1：远程装操作系统
方式2：远程运行操作系统（无盘工作站）


实现PXE网络装机 —— 
基本条件：
  1. DHCP地址分配服务
  2. yum 软件源
PXE引导配置：
    3. 启用TFTP引导服务，提供用来启动客户机的文件资料
1）装包、起服务
# yum  -y  install  tftp-server
# systemctl  restart  tftp
2）提供网卡启动文件 pxelinux.0
# yum  -y  install  syslinux
# cp  /usr/share/syslinux/pxelinux.0   /var/lib/tftpboot/pxelinux.0

—— 建议在客户机pc207先测试，确保可以下载
# yum  -y  install  tftp
!!! 测试方法：tftp  服务器地址   -c  get  文件名
# tftp  192.168.4.7   -c  get  pxelinux.0
# ls  -lh  pxelinux.0 			//确认下载结果

3）提供用来安装XX系统的内核文件（及运行内核所需的初始化文件）
#### 访问 http://192.168.4.254/isolinux/
#### 找到 vmlinuz、initrd.img 文件的下载地址，复制使用
# mkdir  /var/lib/tftpboot/rhel7
# cd  /var/lib/tftpboot/rhel7
# wget  http://vmlinuz文件的下载地址
# wget  http://initrd.img文件的下载地址
# ls  /var/lib/tftpboot/rhel7/  		//确认部署结果
initrd.img  vmlinuz

4）提供pxelinux.0启动程序的配置文件（用来显示启动菜单）
#### 访问 http://192.168.4.254/isolinux/
#### 找到 isolinux.cfg 文件的下载地址，复制使用
# mkdir  /var/lib/tftpboot/pxelinux.cfg/
# cd  /var/lib/tftpboot/pxelinux.cfg/
# wget  http://isolinux.cfg文件的下载地址  -O  default
# cd  /var/lib/tftpboot/
# wget  http://vesamenu.c32图形模块支持文件的下载地址
# wget  http://splash.png背景图片文件的下载地址

# ls  /var/lib/tftpboot/ 		//确认部署结果
pxelinux.cfg  rhel7       vesamenu.c32
pxelinux.0    splash.png
# ls pxelinux.cfg/  				//确认菜单配置文件
default




!!!! TFTP服务的默认资源目录
/var/lib/tftpboot/


!!!! 查找哪一个软件包能够提供 XXXX 文件
# yum  provides  "*/XXXX"

    4. 提供装机菜单
# vim  /var/lib/tftpboot/pxelinux.cfg/default
default  vesamecu.cfg  	//菜单显示由vesa...负责
timeout  600 			//倒计时等待时间（1/10秒）
label  linux
  menu label ^Install Red Hat Enterprise Linux 7.2
  kernel rhel7/vmlinuz  				【第63行】
  append initrd=rhel7/initrd.img   inst.stage2=http://192.168.4.254/rh7dvd  【第64行】

练习：新建一台虚拟机，测试PXE网络装机的效果
1）虚拟机定制：从网络安装、内存2G、硬盘20G、网络private1
2）启动后能成功看到选择菜单
3）选择第一项后，成功加载图形安装程序
4）手动指定分区方式、软件仓库（http://192.168.4.）



客户机的引导过程：
一台需要装RHEL7系统的客户机（裸机）
==》电源 ==》主板开机BIOS自检 ==》优先从网络启动 
==》网卡芯片里的PXE Client程序 
==》获取IP地址、按照DHCP指示去找TFTP服务器 
==》向TFTP服务器索取 pxelinux.0 并下载
==》在内存中运行 pxelinux.0
==》从TFTP资源目录 pxelinux.cfg/default 下载到菜单配置
==》按照default文件配置显示一个选择界面
==》如果客户机的用户选择“Install Red Hat Enterprise Linux 7.2”，那么
==》找TFTP服务器的 rhel7/ 目录下载内核、初始化文件
==》在内存中运行vmlinuz内核文件，由内核获取系统控制权限
==》根据配置的inst.stage2参数指定的位置去获取安装程序
==》在客户机运行安装程序
==》由安装程序主导XX系统安装过程


kernel panic，内核 恐慌


常见错误：
1）配置文件 default 错写为 deafult
2）inst.stage2指定的软件源位置写错 http://.../rhdvd
3）DHCP服务配置中
  subnet  192.168.4.0  netmask  254.254.254.0
4）tftp服务没开启
5）…… 


NIC，Network Interface Card，网卡



实现自动应答的关键配置：
1）需要一份提前准备好的应答文件，客户机必须能够下载
确认访问地址：http://192.168.4.254/ks-rhel7.cfg
2）修改 default 菜单配置使用这份应答文件
# vim  /var/lib/tftpboot/pxelinux.cfg/default
label linux
	.. ..
	kernel rhel7/vmlinuz
	append initrd=rhel7/initrd.img ks=http://192.168.4.254/ks-rhel7.cfg



全自动裸机装配（装系统、配置系统）
yum -y install system-config-kickstart
进行配置，将文件拷贝到裸机能够下载到的真机的http共享里
或者在rhel7的系统中，获取一个已经生成的ks  /root/anaconf-ks.cnf
安装后脚本 —— 使PXE客户机在完成系统安装之后自动执行XX操作
比如：自动配置好yum源
# rm  -rf  /etc/yum.repos.d/*.repo
!!!!
### echo  'yum源配置文件内容'  >  /etc/yum.repos.d/rhel7dvd
# echo  '[rhel7]
name=Red Hat Enterprise Linux 7.2
baseurl=http://192.168.4.254/rh7dvd
gpgcheck=0'  >  /etc/yum.repos.d/rhel7.repo




PXE网络装机，综合性比较强
涉及到服务：dhcpd、httpd、yum、tftp
涉及到文件：tftp


回顾：
1. 通过网络方式来实现安装操作系统
—— HTTP服务端，为客户机提供软件资源
需要的结果： http://192.168.4.254/rh7dvd
可能遇到的问题：
1）httpd服务器没启动
2）防火墙及SELinux忘记关闭
3）软件资源（RHEL7镜像文件）没有挂载成功
4）访问地址/目录名称写错

—— DHCP服务端，为客户机分配IP地址、告诉客户机需要去访问的下一个启动服务器在哪里及去找启动服务器索取一个启动文件
1）装包 dhcp
2）配置
# vim  /etc/dhcp/dhcpd.conf
subnet  网络段地址   netmask  子网掩码  {
	range  起始IP地址    结束IP地址;
	next-server  TFTP启动服务器的IP地址;
	filename  "启动文件的文件名（pxelinux.0）";
}
3）起服务 dhcpd

—— TFTP启动服务端，为客户机提供启动文件、装系统用的素材
1）装包 tftp-server
2）配置，提供各种素材文件（用来启动客户机、为客户机装系统）
### 网卡启动文件，以及配套的模块文件、背景图片
/var/lib/tftpboot/pxelinux.0
/var/lib/tftpboot/vesamenu.c32
/var/lib/tftpboot/splash.png
### 决定客户机显示界面如何展示
/var/lib/tftpboot/pxelinux.cfg/default

@@@ 这些文件从哪来：
sysliniux 软件包安装的结果文件
# yum  provides  "*/pxelinux.0" 	
  						【查哪个软件包能提供XX文件】
# rpm  -ql  syslinux 	【查软件包装了哪些文件】
XX版本光盘目录 isolinux/isolinux.cfg

### XX系统安装引导文件（内核、初始化文件）
/var/lib/tftpboot/rhel7/vmlinuz
/var/lib/tftpboot/rhel7/initrd.img
/var/lib/tftpboot/rhel6/vmlinuz
/var/lib/tftpboot/rhel6/initrd.img
.. .. 

@@@ 这些文件从哪来：
找XX版本系统的光盘目录 isolinux/

3）起服务 tftp



关于客户机的PXE启动菜单的显示：
手动安装 —— 
# vim  /var/lib/tftpboot/pxelinux.cfg/default
63 kernel rhel7/vmlinuz
64 append initrd=rhel7/initrd.img  inst.stage2=http://192.168.4.254/rh7dvd



2. 让网络装机的过程能够自动完成
无人值守安装 —— 
# vim  /var/lib/tftpboot/pxelinux.cfg/default
63 kernel rhel7/vmlinuz
64 append initrd=rhel7/initrd.img ks=http://192.168.4.254/ks-rhel7.cfg

准备工作：
1）提前准备一份可用的应答文件 ks-rhel7.cfg
# system-config-kickstart 

!!!! 
先装system-config-kickstart包
修改 yum源的id，设为 [development]

2）确保从客户机 http://192.168.4.254/ks-rhel7.cfg 能够访问第1）步准备的这一份应答文件



TFTP+DHCP启动服务器备份与恢复 ——
备份：
# tar  -zcPf  /opt/pxeconf.tar.gz  /var/lib/tftpboot/  /etc/dhcp/dhcpd.conf

恢复：
# yum  -y  install  dhcp  tftp-server
# tar  -xPf   /opt/pxeconf.tar.gz
# systemctl  restart  dhcpd  tftp



关于客户机的PXE启动菜单的显示（补充）：
# vim  /var/lib/tftpboot/pxelinux.cfg/default
default vesamenu.c32 			//支持图形显示
timeout 600 						//等待超时60秒
menu background  splash.png  	//背景图片
menu title 菜单标题文字
label 启动项1的ID
  menu label 启动项1显示的文字
  kernel 内核文件vmlinuz的相对路径
  append initrd=初始化文件initrd.img的相对路径 .. ..
label centos7
  menu label Install ^CentOS 7.4  	//^定义快捷键
  kernel centos7/vmlinuz
  append initrd=centos7/initrd.img .. .. 
label local
  menu label Boot from ^local drive
  menu default
  localboot 0xffff


配置default文件时，可以使用 ^ 来定义快捷键，加载menu  label 后面的显示文件内的某一个字母前面

vim末行模式，删除连续的多行文本 ——
:73,114d





应用场景：
DNS轮询、分离解析，==》
同一个域名www.tedu.cn，有多个IP地址/服务器

rsync 同步操作 ——
保持 主机1的目录1    主机2的目录2  的内容要一致


# rsync  目录1   目录2

同步与复制（cp、scp）命令不一样

假设目录1的大小是500M，
执行 cp、scp 复制时，也需要传输500M数据到 目录2
执行 rscyn 同步时，只传输目录2中没有/不一样的数据

假设 目录1 增加/修改了 5M，


本地同步 ——
# rsync [选项...] 本机目录1    本机目录2

rsync+sshd远程同步 ——
浏览远程目录资源：
# rsync  远程用户@远程主机地址:远程目录/

上传（上行同步）：
# rsync [选项...] 本机目录1   远程用户@远程主机地址:远程目录2
下载（下行同步）：
# rsync [选项...] 远程用户@远程主机地址:远程目录1  本机目录2


请思考：从远程主机获取一个文件有哪些方式？
U盘、电子邮件、httpd、ftp、nfs、samba、scp、rsync、……



同步的含义 —— 两边数据要完全一样（时间、属性、去除多余文档）
# rsync  -az  --delete  目录1/   目录2


统计目录占用的空间大小
# du  -sh  /etc


由管理员手动执行rsync同步操作

通过计划任务定期执行rsync同步操作（间隔时间）

实时/触发同步 —— 当目录1的内容变化时，马上执行同步到目录2


需要安装 inotify-tools

练习：inotify+rsync 实时同步 ——
目录1：svr7上的 /var/www/html/
目录2：pc207上的 /var/www/html/
效果：当svr7上的目录内容变化时，pc207上也会立即做相应的变化

在CentOS7真机上，获取安装文件并上传给虚拟机svr7 ——
# wget 
http://172.40.50.113/tools/inotify-tools-3.13.tar.gz
# scp inotify-tools-3.13.tar.gz 192.168.4.7:/root

在虚拟机svr7上 ——
1）安装 inotify-tools 软件包
# yum  -y  install  gcc 		//准备编译环境【厨房】
# tar  -xf  inotify-tools-3.13.tar.gz  -C  /usr/src/
# cd  /usr/src/inotify-tools-3.13/
# ./configure  				//配置【准备几颗鸡蛋.. ..】
# make						//编译【炒菜】
# make  install  			//安装【装盘上桌】

# inotifywait  --help 		//确认安装结果（命令可用）

2）学会使用 inotifywait 命令来实现监控
# inotifywait  -rq  -e  create,move,delete,modify,attrib  目录1/

3）inotifywait+rsync结合，实现实时同步

当  XXXX的时候
do
	做YYYY操作
done

while  目录1的内容有变化的时候
do
	rsync  ...  目录1/   目录2
done


while  inotifywait  -rq  -e  create,move,delete,modify,attrib  目录1/
do
	rsync  ...  目录1/   目录2
done


[root@svr7 ~]# cat /root/isync.sh 
#!/bin/bash
while  inotifywait  -rq  -e  create,move,delete,modify,attrib  /opt/
do
	rsync  -az  --delete  /opt/   /opt2
done &



!!!! 实现SSH免密码登录
实现方式：提前部署一个密钥文件到远程机器
1）在 svr7 生成密钥文件
===> 先检查是否已经有密钥文件
# ls  ~/.ssh/id*
===> 如果没有密钥文件，那么再生成（否则跳过此步）
# ssh-keygen 				//根据提示确认3次

2）把密钥部署给远程的机器 pc207
# ssh-copy-id  root@192.168.4.207

3）验证结果（在 svr7 上远程登 pc207 不需要密码）
# ssh  root@192.168.4.207
.. .. 不需要密码直接登录成功  



客户机svr7上的用户A创建密钥，并且部署给pc207的用户B、部署给pc208的用户C

最终实现的效果：
在svr7上的用户A 可以执行  ssh  B@pc207 ，免密码
在svr7上的用户A 可以执行  ssh  C@pc208 ，免密码


1）在svr7上编写/root/isync.sh实时同步脚本
#!/bin/bash
mulu1="/var/www/html/"
tongbu="rsync  -az  --delete  /var/www/html/   root@192.168.4.207:/var/www/html"
while  inotifywait  -rqq  -e  create,move,delete,modify,attrib  $mulu1
do
        $tongbu
done &
2）为脚本添加执行权限
# chmod  +x  /root/isync.sh
3）执行脚本并测试
# /root/isync.sh 
.. .. 修改svr7上/var/www/html/目录内容，观察pc207变化
!!!! 需要停止实时同步时，pkill  -9  inotifywait


!!!! inotifywait的小bug
当被监控目录下有子目录被删除时，会导致 inotifywait 退出



日志管理（日记管理）  
—— 通过去查看系统/程序/服务的日记来了解发生了什么事，从而可以排查错误、获取证据

常见的日志文件有哪些？ ——
内核/系统日志：文本文件，记录格式类似
/var/log/messages —— 公共日志文件（所有系统服务可以记录）
/var/log/dmesg —— 记录系统启动过程的各种消息
/var/log/cron —— 计划任务配置及执行相关的消息
/var/log/secure —— 安全认证相关的消息

练习：分析内核/系统日志
1）故意改错 /etc/named.conf 文件
查看日志文件 /var/log/messagese 末尾的内容
2）编辑一个计划任务，内容任意
查看日志文件 /var/log/cron 末尾的内容
3）远程连接svr7，以一个不存在的用户或错误的密码验证
查看日志文件 /var/log/secure 末尾的内容

熟悉常见的计算机专业英语单词 ——
error：错误的
failed：失败的
unknown：未知的
incorrect：不正确的
invalid：无效的
successful：成功的
……


常见的用户日志文件有哪些？ ——
用户日志：二进制文件

练习：分析用户登录情况
1）查看当前有哪些用户登录、在做什么操作
users，列出登录的用户名
who，列出登录用户名、来源
w，列出系统负载、登录用户名、来源 、在执行的命令、……
2）了解过去有哪些用户登录过
last  -2  [用户名]
3）了解过去有哪些用户登录失败过
lastb  -2  [用户名]


练习：实时跟踪日志文件的变化（tailf）
# tailf   /var/log/maillog
.. .. 新增的日志内容会立即显示出来


练习：筛选日志内容（journalctl）
筛选方式：关键词、系统服务、条数、重要程度、日志产生的时间段
# journalctl  |  grep  8909
# journalctl  -u  httpd
# journalctl  -n  记录的数量
# journalctl  -p  重要程度
# journalctl  --since="起始时间"  --until="结束时间"


!!! 添加 --no-pager 阻止左右分屏
!!! 提示：按 q 退出



今日重点：
1）理解远程同步的含义
2）掌握 rsync+ssh 远程同步操作
3）了解常见的日志文件，学会通过查看这些日志来找出问题原因





rootkit 一套伪造过的系统命令



