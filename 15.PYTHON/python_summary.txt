python


· 特点
- 高级：高级的数据结构，缩短开发时间与代码量
- 面向对象：
- 可升级
- 可扩展
- 可移植性
- 易学
- 易读
- 内存管理器


安装配置

www.python.org

安装依赖包

[root@room9pc01 ~]# yum -y install gcc gcc-c++ zlib-devel openssl-devel readline-devel libffi-devel sqlite-devel tcl-devel tk-devel

安装python3
•  官方站点
–  http://www.python.org
•  选择正确的系统
•  选择正确的版本

编译安装
tar	xzf	Python-3.6.4.tar.gz
cd	Python-3.6.4
./configure	--prefix=/usr/local	
make	&&	make	install	
[root@room9pc01 ~]# python3 --version
Python 3.6.1


设置pycharm
•  Pycharm是由JetBrains打造的一款Python IDE
•  支持的功能有:
–  调试、语法高亮
–  Project管理、代码跳转
–  智能提示、自动完成
–  单元测试、版本控制
•  下载地址:https://www.jetbrains.com/pycharm/download
•  分为收费的专业版和免费的社区版

激活
在终端运行./crack
pycharm开始界面：
选liscence server，输入http://127.0.0.1:1017 点activate

Git简介
•  Git是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。
•  Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。
•  Git 与常用的版本控制工具 CVS, Subversion 等不同,它采用了分布式版本库的方式,不必服务器端软件支持。

Git：分布式版本控制工具
1、安装
[root@room9pc01 ~]# yum -y install git

2、提交代码需要配置个人信息
[root@room9pc01 ~]# git config --global user.name "gaopf"
[root@room9pc01 ~]# git config --global user.email "936849313@qq.com"

3、设置编写代码说明的编辑器是vim
[root@room9pc01 ~]# git config --global core.editor vim

4、查看
[root@room9pc01 ~]# git config --list
[root@room9pc01 ~]# cat ~/.gitconfig


Git工作流程
工作区、暂存区和版本库
•  工作区:就是你在电脑里能看到的目录
•  暂存区:英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件(.git/index)中,
所以我们把暂存区有时也叫作索引(index)
•  版本库:工作区有一个隐藏目录.git,这个不算工作区,而是Git的版本库

5、创建工作区
•  Git 使用 git init 命令来初始化一个 Git 仓库,Git 的
很多命令都需要在 Git 的仓库中运行,所以 git init
是使用 Git 的第一个命令。
[root@room9pc01 ~]#mkdir	devops	

6、初始化版本库
[root@room9pc01 ~]#cd devops/	
[root@room9pc01 devops]#	git init .或	
[root@room9pc01 ~]#git init devops	
[root@room9pc01 devops]# ls -a

7、编写程序文件
[root@room9pc01 devops]# echo 'hello world' > hi.txt
[root@room9pc01 devops]# git status		//查看状态

8、添加跟踪文件（所有文件）到版本库
[root@room9pc01 devops]# git add .	
[root@room9pc01 devops]# git status

9、提交文件到版本库
[root@room9pc01 devops]# git commit -m "add hi.txt"
//git commit -am "向hello.py添加新行"	将add和commit一起执行
[root@room9pc01 devops]# git status
# 位于分支 master
无文件要提交，干净的工作区

10、修改hi.txt
[root@room9pc01 devops]# echo haha >> hi.txt
[root@room9pc01 devops]# git add .
[root@room9pc01 devops]# git commit -m "modify hi.txt"

11、恢复hi.txt到以前的版本
[root@room9pc01 devops]# git log
commit 0b93cd4b9d191fcfa50b8203be606c0d2aa56099
Author: gaopf <936849313@qq.com>
Date:   Mon Jul 16 11:30:40 2018 +0800

    add hi.txt
[root@room9pc01 devops]# git checkout 0b93cd4b9d191fcfa50b8203be606c0d2aa56099
[root@room9pc01 devops]# cat hi.txt 
hello world

12、如果有误加入到版本库的文件，查看他，然后删除
[root@room9pc01 devops]# git ls-files
[root@room9pc01 devops]# git rm hi.txt
[root@room9pc01 devops]# git commit -m "delete hi.txt"


搭建本地gitlab服务器
1、创建一台虚拟机，内存加到4G
node1.tedu.cn	192.168.1.1
2、把docker程序和镜像拷贝到虚拟机中
3、安装docker
cd /root/zzg_python_5/docker/docker_pkgs
yum -y install * .rpm
4、启动服务
[root@node1 docker_pkgs]# systemctl restart docker
[root@node1 docker_pkgs]# systemctl enable docker
5、导入镜像
[root@node1 docker]# docker load < images/gitlab_zh.tar
6、为了方便gitlab容器的运行，将node1的ssh服务切换成2222端口
[root@node1 docker]# vim /etc/ssh/sshd_config 
Port 2222
[root@node1 docker]# systemctl restart sshd
7、重新登录到node1
[root@room9pc01 ~]# ssh 192.168.1.1 -p 2222
8、启动新容器。将容器的443、80、22端口发布出去。当容器意外停止的时候，将其重启。再将容器的配置目录、日志目录、数据目录映射到本机/srv/gitlab目录。如果映射目录没有写，就是和本机一样。-v /srv/gitlab/data

[root@node1 ~]# docker run -d -h gitlab --name gitlab -p 443:443 -p 80:80 -p 22:22 --restart always -v /srv/gitlab/config:/etc/gitlab -v /srv/gitlab/logs:/var/log/gitlab -v /srv/gitlab/data gitlab_zh:latest

稍等一会再访问http://192.168.1.2


9、配置gitlab
（1）访问http://192.168.1.1，第一次访问需要设置密码，密码必须8位以上，如1234.com
（2）登录账户，root，1234.com
（3）创建群组，群组路径和名字填写devops，类型为公开
（4）创建群组后，右下角创建项目
（5）拉取项目测试
[root@room9pc01 tmp]# git clone http://192.168.1.1/devops/core_py.git


以下三种情况的使用说明：第一是现在gitlab上创建项目，然后clone到本地，最后在本地进入目录开始编写代码；
第二种情况是本地已有一个目录
第三种情况是
命令行指令
￼
Git 全局设置
git config --global user.name "Administrator"
git config --global user.email "admin@example.com"

￼
创建新版本库
git clone http://gitlab/devops/core_py.git
cd core_py
touch README.md
git add README.md
git commit -m "add README"
git push -u origin master

￼
已存在的文件夹
cd existing_folder
git init
git remote add origin http://gitlab/devops/core_py.git
git add .
git commit -m "Initial commit"
git push -u origin master

￼
已存在的 Git 版本库
cd existing_repo
git remote rename origin old-origin
git remote add origin http://gitlab/devops/core_py.git
git push -u origin --all
git push -u origin --tags


10、创建用户、授权可以向项目中提交代码
左上角扳手，new user。新建用户时不能设置密码，创建成功后，点击编辑设置密码

11、root用户将新建的用户加入到群组中，并且设置新用户为“主程序员”，用户就可以上传代码

12、在本地配置新用户，实现上传代码
（1）在gitlab的web页面上注销root用户，用新用户登录
（2）用户在本地生成ssh秘钥
[root@client ~]# ssh-keygen -t rsa -C "your.email@example.com" -b 4096
（3）查看秘钥内容
[root@client ~]# cat .ssh/id_rsa.pub 
（4）在gitlab页面上点击左侧边栏的ssh秘钥，把第（3）步查看到的秘钥粘贴进来

13、本地上传代码测试
（1）创建本地版本库
[root@room9pc01 ~]# mkdir myproject
[root@room9pc01 ~]# cd myproject
[root@room9pc01 myproject]# cp /etc/hosts .
[root@room9pc01 myproject]# git init 
[root@room9pc01 myproject]# git add .
[root@room9pc01 myproject]# git commit -m "init myproject"
（2）上传代码
[root@room9pc01 myproject]# git remote rename origin old-origin
如果出现一下错误，可以忽略
error: 不能重命名配置小节 'remote.origin' 到 'remote.old-origin'
[root@room9pc01 myproject]# git config --global user.name "gaopf"
[root@room9pc01 myproject]# git config --global user.email "936849313@qq.com"
//git的全局变量会存放在：~/.gitconfig 
[root@room9pc01 myproject]# git remote add origin git@192.168.1.1:/devops/core_py.git
[root@room9pc01 myproject]# git push -u origin --all
//这里如果报错权限不对，是因为虽然公钥已经拷贝过去了，但是自己的私钥没有添加，在本机执行ssh-add和ssh-agent
就可以了

（3）如果有代码的修改，只要git add /git commit /git push 即可
[root@room9pc01 myproject]# cp /etc/passwd .
[root@room9pc01 myproject]# git add .
[root@room9pc01 myproject]# git commit -m "add new file passwd"
[root@room9pc01 myproject]# git push


排错
问题1
[root@room9pc01 python]# git push -u origin --all
Warning: the ECDSA host key for 'gitlab' differs from the key for the IP address '192.168.1.1'
Offending key for IP in /root/.ssh/known_hosts:19
Matching host key in /root/.ssh/known_hosts:48
Are you sure you want to continue connecting (yes/no)? yes
sign_and_send_pubkey: signing failed: agent refused operation
Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
针对上面错误的解决方案
[root@room9pc01 python]# ssh-add 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions 0644 for '/root/.ssh/id_rsa' are too open.( 表示私钥的权限太大)
It is required that your private key files are NOT accessible by others.
This private key will be ignored.

针对私钥的权限太大问题
[root@room9pc01 python]# chmod 0600 /root/.ssh/id_rsa

[root@room9pc01 python]# ssh-add的正确结果
Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa)


问题2
[root@room9pc01 python]# git push -u origin --all
Warning: the ECDSA host key for 'gitlab' differs from the key for the IP address '192.168.1.1'
Offending key for IP in /root/.ssh/known_hosts:19
Matching host key in /root/.ssh/known_hosts:48
Are you sure you want to continue connecting (yes/no)? yes
To git@gitlab:root/core_pyxx.git
 ! [rejected]        master -> master (non-fast-forward)
error: 无法推送一些引用到 'git@gitlab:root/core_pyxx.git'
提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。
提示：再次推送前，先与远程变更合并（如 'git pull'）。详见
提示：'git push --help' 中的 'Note about fast-forwards' 小节。

出现上述报错的原因是当前分支的最新提交落后于其他对应的远程分支，所有我们先从远程库fetch到更新，再和本地库合并，之后就可以git　push操作了．
[root@room9pc01 python]#git fetch origin
[root@room9pc01 python]# git merge origin/master
[root@room9pc01 python]# git push -u origin --all








Python起步

Python运行方式
交互解释器
•  进入交互解释器
[root@zzghost1 bin]# python3	
Python 3.6.3 (default, Oct 13 2017, 11:38:12)	
[GCC 4.8.5 20150623 (Red	Hat	4.8.5-4)] on linux	
Type "help", "copyright", "credits" or "license" for more informaeon.	
>>>	
•  退出交互解释器
>>>exit()	
或	
>>>ctrl+d	

文件形式
•  明确指定解释器
[root@zzghost1 day01]#python3 hello.py	
•  赋予python文件可执行权限
[root@zzghost1 day01]#chmod +x hello.py	
[root@zzghost1 day01]# ./hello.py	

Python语法结构

语句块缩进
•  python代码块通过缩进对齐表达代码逻辑而不是使用大括号
•  缩进表达一个语句属于哪个代码块
•  缩进风格
–  1或2:可能不够,很难确定代码语句属于哪个块
–  8至10:可能太多,如果代码内嵌的层次太多,就会使得代码很难阅读
–  4个空格:非常流行, 范·罗萨姆支持的风格
•  缩进相同的一组语句构成一个代码块,称之代码组
•  首行以关键字开始,以冒号 : 结束,该行之后的一行或多行代码构成代码组
•  如果代码组只有一行,可以将其直接写在冒号后面,但是这样的写法可读性差,不推荐

注释及续行
•  首要说明的是:尽管Python是可读性最好的语言之
一,这并不意味着程序员在代码中就可以不写注释
•  和很多UNIX脚本类似,python注释语句从#字符开始
•  注释可以在一行的任何地方开始,解释器会忽略掉该行#之后的所有内容
•  一行过长的语句可以使用反斜杠\分解成几行

在项目右键 copy path 就可以到命令行终端cd到目录，执行python3 xxx.py 执行
在pycharm里面也可以直接执行 crtl+shift+f10

选中想要注释的行 ctrl+？，取消注释一样

同行多个语句
•  分号 ; 允许你将多个语句写在同一行上
•  但是这些语句不能在这行开始一个新的代码块
•  因为可读会变差,所以不推荐使用


print('hello world!')
print('hello','world!')         #逗号自动添加空格
print('hello'+'world!')         #加号表示字符拼接
print('hello','world',sep='****')   #单词间用****分隔
print('#' * 50)     # *号表示重复50遍
print('how are u?',end='')  #默认print会打印回车,end=''表示不要回车

number = input("请输入数字： ")   #input用户获取键盘输入
print(number)   #input 获得的数据全是字符
print(number + 20)  #报错，不能把字符和数字做运算

user = input('请输入用户名')
print('热烈欢迎' + user)
print('热烈欢迎',user)


Python变量

变量定义
•  变量名称约定
–  第一个字符只能是大小写字母或下划线
–  后续字符只能是大小写字母或数字或下划线
–  区分大小写
•  python是动态类型语言,即不需要预先声明变量的类型

•  推荐采用的全名方法
–  变量名全部采用小写字母
–  简短、有意义
–  多个单词间用下划线分隔
–  变量名用名词,函数名用谓词(动词+名词)
–  类名采用驼峰形式


变量赋值
•  变量的类型和值在赋值那一刻被初始化,自右向左运算
•  变量赋值通过等号来执行
>>>	counter = 0	
>>>	name = 'bob'	
•  python也支持增量赋值
>>> n	+= 1		#等价于n = n + 1	
>>> n	*= 1		#等价于n = n	* 1	
>>> i++	
File	"<stdin>",	line	1	
  i++							^	
SyntaxError: invalid syntax	

运算符
•  标准算术运算符
+ - * / //(丢弃余数，只保留商) % **（幂运算）
•  比较运算符
< <= > >= == != <>
•  逻辑运算符
and not or

print(5 / 2)  # 2.5
print(5 // 2)  # 丢弃余数，只保留商
print(5 % 2)  # 求余数
print(5 ** 3)  # 5的3次方
print(5 > 3)  # 返回True
print(3 > 5)  # 返回False
print(20 > 10 > 5)  # python支持连续比较
print(20 > 10 and 10 > 5)  # 与上面相同含义
print(not 20 > 10)  # False






Python开发入门

数字

基本数字类型
•  int:有符号整数
•  bool:布尔值
–  True:1
–  False:0
•  float:浮点数
•  complex:复数

数字表示方式
•  python默认以十进制数显示
•  数字以0o或0O开头表示为8进制数
•  数字以0x或0X开头表示16进制数
•  数字以0b或0B开头表示2进制数

python3 终端修改文件权限
import os
os.chmod("/tmp/passwd",0o600)


字符串
定义字符串
•  python中字符串被定义为引号之间的字符集合
•  python支持使用成对的单引号或双引号
•  无论单引号,还是双引号,表示的意义相同
•  python还支持三引号(三个连续的单引号或者双引号),可以用来包含特殊字符,支持换行回车，可以保持输入格式
•  python不区分字符和字符串

>>> sentence = "tom's cat is dog"
>>> sentence
"tom's cat is dog"
>>> sentence1 = 'tom said "cat is dog"'
>>> sentence1
'tom said "cat is dog"'
>>> words = '''
... haha
... xix
... tang'''
>>> words
'\nhaha\nxix\ntang'
>>> print (words)

haha
xix
tang

字符串切片
•  使用索引运算符[ ]和切片运算符[ : ]可得到子字符串
•  第一个字符的索引是0,最后一个字符的索引是-1
•  子字符串包含切片中的起始下标,但不包含结束下标
>>> py_str = 'Python'	
>>> py_str[0]	
'P'	
>>> py_str[-2]	倒数第二个字符
'o'	
>>> py_str[2:4]	切片，起始下标包含，结束下标不包含
'th'	
>>> 'python'[0]
'p'
>>> len(py_str)	取字符串长度
6
>>> py_str[6]	错误，下标超出范围
>>> py_str[2:6]
'thon'
>>> py_str[2:60]
'thon'
>>> py_str[2:]	从下标为2的字符取到结尾
'thon'	
>>> py_str[:4]	从开头取到下标是4之前的字符
'Pyth'
>>> py_str[:]	取全部字符
'python'
>>> py_str[::2]	步长值2，默认是1
'pto'
>>> py_str[1::2]	
'yhn'
>>> py_str[::-1]	步长为负，表示倒序，前面的取值要从大到小取
'nohtyp'

>>> py_str[:3:-1]	更确切的讲，-1表示倒序，这里表示从最后一位到第三位，第三位不包括
'no'
>>> py_str[:4:-1]
'n'
>>> py_str[:1:-1]
'noht'
>>> py_str[3::-1] 这里也是倒序，从最开始一位到第三位，第三位包括
'htyp'
>>> py_str[3:-1]
'ho'
>>> py_str[1::-1]
'yp'
>>> py_str[1:5:-1]
''
>>> py_str[3:1:-1] 从第三位到第一位，第三位包括，第一位不包括
'ht'

字符串连接操作
•  使用+号可以将多个字符串拼接在一起
•  使用*号可以将一个字符串重复多次
>>> py_str = 'python'	
>>> is_cool = 'is Cool‘	
>>> print py_str + ''+ is_cool	
python is Cool	
>>> py_str *2	
'pythonpython'	


定义列表
•  可以将列表当成普通的“数组”,它能保存任意数量
任意类型的python对象
•  像字符串一样,列表也支持下标和切片操作
•  列表中的项目可以改变
>>> alist = [1,"tom",2,"alice"]	
>>> alist[1] = 'bob‘	重新定义第一个下标的值
>>> alist[2:]

>>> alist = [1,"tom",2,"alice",[1,2,3]]
>>> alist[-1]
[1, 2, 3]
>>> alist[-1][-1]		取完下标之后，可以对取出来的继续取下标
3

成员关系判断
>>> 'o' in py_str
True
>>> 'to' in py_str
False
>>> 'to' not in py_str
True

>>> alist.append(200)	在列表中追加一项

元组的定义及操作
•  可以认为元组是“静态”的列表
•  元组一旦定义,不能改变
>>>atuple=(1,"tom",2,"alice")	
>>>'tom' in	atuple	
True	
>>>atuple[0] =3	报错，元组的值不能变	

字典
字典的定义及操作
•  字典是由键-值(key-value)对构成的映射数据类型
•  通过键取值,不支持下标操作

>>> adic = {'name':'bob','age':23}
>>> len(adic)
2
>>> 'bob' in adic
False
>>> 'name' in adic
True
>>> adic['name']
'bob'

数据类型比较
•  按存储模型分类
–  标量类型:数值、字符串
–  容器类型:列表、元组、字典
•  按更新模型分类:
–  可变类型:列表、字典
–  不可变类型:数字、字符串、元组
•  按访问模型分类
–  直接访问:数字
–  顺序访问:字符串、列表、元组
–  映射访问:字典

非常重要

列表可变，这里blist和alist标注的是内存的同一块空间，所以b改变a也改变
>>> alist
[1, 'tom', 2, 'alice', [1, 2, 3], 200]
>>> blist = alist
>>> blist[0]=2
>>> blist
[2, 'tom', 2, 'alice', [1, 2, 3], 200]
>>> alist
[2, 'tom', 2, 'alice', [1, 2, 3], 200]

clist通过alist取值的方式赋值，相当于给clist重新开辟一块内存空间，c变a不变
>>> clist = alist[:]
>>> clist[0]=3
>>> clist
[3, 'tom', 2, 'alice', [1, 2, 3], 200]
>>> alist
[2, 'tom', 2, 'alice', [1, 2, 3], 200]


判断语句

if语句语法结构
•  标准if条件语句的语法
if expression:	
	if_suite	
else:	
	else_suite	
•  如果表达式的值非0或者为布尔值True, 则代码组if_suite被执行;否则就去执行else_suite
•  代码组是一个python术语,它由一条或多条语句组成,表示一个子代码块

if 3>0 :
    print('yes')
    print('ok')
print('done')
if 'i' in 'print' :	
    print('haha')
if 0:
    print('no')		任何值为0的数字就是False
if 10 not in ('9','8','7'):
    print('duide')	非空对象都是True
if ' ':
    print('shikongde ')  空格字符也是字符，条件为True

•  只要表达式数字为非零值即为True
•  空字符串、空列表、空元组,空字典的值均为False

user = input('请输入用户名：')
passwd = input('请输入密码：')
if user == 'bob' and passwd == '123456':
    print('Login successful')
else:
    print('Login inorrect')


import getpass  # 导入模块
username = input('username: ')
# getpass模块中，有一个方法也叫getpass
password = getpass.getpass('password: ')      #输入的密码不显示

if username == 'bob' and password == '123456':
    print('Login successful')
else:
    print('Login incorrect')




import random
num = int(input ('guess a number:'))
answer = random.randint(1, 10)      从1到10,包含10
if num > answer :
    print ('caidale')
elif num < answer :
    print ('caixiaole')
print ('correct number:',answer)


grade = int( input('输入成绩'))
if grade > 90 :
    print('优秀')
elif grade > 80 :
    print('好')
elif grade > 70 :
    print('良')
elif grade > 60 :
    print('及格')
else:
    print('要努力了')

grade = int( input('输入成绩'))
if grade >= 60 and grade <70 :
    print('及格')
elif 70<= grade < 80 :
    print('良')
elif 80 <= grade < 90 :
    print('好')
elif grade >= 90 : 
    print('优秀')
else:
    print('要努力了')

vim -O file1 file2   分屏显示  ctrl +w 左右进行调整

条件表达式
•  Python 在很长的一段时间里没有条件表达式(C ?X:Y),或称三元运算符,因为范·罗萨姆一直拒绝加入这样的功能
•  从Python 2.5集成的语法确定为: X if C else Y
>>>x,y=3,4	
>>>smaller = x if x < y else y	
>>>print (smaller)	
3	

案例3:编写石头剪刀布小游戏
•  编写game.py,要求如下:
1.  计算机随机出拳
2.  玩家自己决定如何出拳
3.  代码尽量简化

import random
allchoices = ['石头','剪刀','布']
winlist = [['石头','剪刀'],['剪刀','布'],['布','石头']]

computer = random.choice (allchoices)
player = input('请出拳：')

print("your choice: %s ,computer's choice : %s" %(player,computer))
if player == computer :
    print ('pingju')
elif [player,computer] in winlist :
    print('you win!!!')
else:
    print('you lose!!!')


>>> import this  # python之禅
美胜丑，明胜暗，简胜繁

优化简化
import random
allchoices = ['石头','剪刀','布']
winlist = [['石头','剪刀'],['剪刀','布'],['布','石头']]
ind = int(input('''(0) 石头
(1) 剪刀
(2) 布
请选择（0/1/2）:'''))
computer = random.choice (allchoices)
player = allchoices[ind]

print("your choice: %s ,computer's choice : %s" %(player,computer))
if player == computer :
    print ('\033[32;1mpingju\033[0m')			#32是绿色
elif [player,computer] in winlist :
    print('\033[31;1myou win!!!\033[0m')			#31是红色
else:
    print('\033[31;1myou lose!!!\033[0m')


while循环

循环语句基础
•  一组被重复执行的语句称之为循环体,能否继续重复,决定循环的终止条件
•  Python中的循环有while循环和for循环
•  循环次数未知的情况下,建议采用while循环
•  循环次数可以预知的情况下,建议采用for循环

while循环语法结构

•  当需要语句不断的重复执行时,可以使用while循环
while	expression:	
    while_suite	
•  语句while_suite会被连续不断的循环执行,直到表达式的值变成0或False
sum100 = 0	
counter = 1	
	
while	counter <= 100:
    sum100 += counter
    counter += 1
print	("result is %d" %	sum100)		#  %d 为数字，%s为文本

划中所选区域，按table键就把对应的行前加一个table
划中所选区域，按shift +table键就把对应的行前减一个table


break语句
•  break语句可以结束当前循环然后跳转到下条语句
•  写程序的时候,应尽量避免重复的代码,在这种情况
下可以使用while-break结构

python 的DRY原则：don't repeat yourself


while 1:
    yn = input('Continue(y/n):')
    if yn in ['n','N'] :
        break
    print('running...')			精简原则，这里的else：可以省去

  continue语句
•  当遇到continue语句时,程序会终止当前循环,并忽略剩余的语句,然后回到循环的顶端
•  如果仍然满足循环条件,循环体内语句继续执行,否则退出循环 
sum100 = 0
counter =0
while counter < 100 :
    counter += 1
    if counter % 2 :
        continue
    sum100 += counter
print(sum100)

else语句
•  python中的while语句也支持else子句
•  else子句只在循环完成后执行
•  break语句也会跳过else块

案例
•  编写guess.py,要求如下:
1.  系统随机生成100以内的数字
2.  要求用户猜生成的数字是多少
3.  最多猜5次,猜对结束程序
4.  如果5次全部猜错,则输出正确结果


import random

num = random.randint(1, 10)
counter = 0

while counter < 5:
    answer = int(input('guess the number: '))
    if answer > num:
        print('猜大了')
    elif answer < num:
        print('猜小了')
    else:
        print('猜对了')
        break
    counter += 1
else:  # 循环被break就不执行了，没有被break才执行
    print('the number is:', num)


案例:完善石头剪刀布小游戏
•  编写game2.py,要求如下:
1.  基于上节game.py程序
2.  实现循环结构,要求游戏三局两胜

import random
allchoices = ['石头','剪刀','布']
winlist = [['石头','剪刀'],['剪刀','布'],['布','石头']]
promt = '''(0) 石头
(1) 剪刀
(2) 布
请选择（0/1/2）'''
winnum = 0
losenum = 0
while winnum <2 and losenum <2:
    computer = random.choice(allchoices)
    ind = int(input(promt))
    player = allchoices[ind]
    print("your choice: %s, computer's choice: %s" %(player,computer) )
    if player == computer :
        print('\033[32;1m平局\033[0m')
    elif [player,computer] in winlist :
        winnum += 1
        print('\033[31;1mYOU WIN\033[0m',winnum,'times')
    else:
        losenum += 1
        print('\033[31;1mYOU LOSE\033[0m',losenum,'times')

else:
    if winnum == 2:
        print('\033[31;1mFinally:YOU WIN!!!\033[0m')
    else :
        print('\033[31;1mFinally:YOU LOSE!!!\033[0m')











Python开发入门

for循环


for循环语法结构
•  python中的for接受可迭代对象(例如序列或迭代器)作为其参数,每次迭代其中一个元素
for iter_var in iterable:	
    suite_to_repeat	
•  与while循环一样,支持break、continue、else语句
•  一般情况下,循环次数未知采用while循环,循环次数已知,采用for循环

for循环的范围可以是字符串、列表、元组、字典、文件


astr = 'hello'
alist = [10, 20, 30]
atuple = ('bob', 'tom', 'alice')
adict = {'name': 'john', 'age': '23'}

for ch in astr :
    print(ch)
for i in alist :
    print(i)
for name in atuple :
    print(name)
for key in adict :
    print('%s:%s' %(key,adict[key]))


range函数
•  for循环常与range函数一起使用
•  range函数提供循环条件，
•  range函数的完整语法为:
range(start, end, step =1)  不包含末尾，默认开头是0，步长是1

list函数把字符串转换成列表

s = 'Python2best'
s2 = []
for ch in s :
    s2.append(ch)
print(s2)

print(list(s))

range(10)   [0,1,2,3,4,5,6,7,8,9]
range(6,11) [6,7,8,9,10]
range(1,10,2) [1,3,5,7,9]
range(10,3,-1) [10,9,8,7,6,5,4]

sum100 = 0
for i in range(1,101) :
    sum100 += i
print(sum100)

案例1:斐波那契数列
1.  斐波那契数列就是某一个数,总是前两个数之和,
比如0,1,1,2,3,5,8
2.  使用for循环和range函数编写一个程序,计算有10
个数字的斐波那契数列
3.  改进程序,要求用户输入一个数字,可以生成用户
需要长度的斐波那契数列

fib=[0,1]
num = int(input('请输入一个数字： '))

for i in range(len(fib),num) :
    fib.append(fib[i-2] + fib[i-1])
print(fib)



案例2:九九乘法表
1.  创建mtable.py程序
2.  乘序运行后,可以在屏幕上打印出九九乘法表课
3.  修改程序,由用户输入数字,可打印任意数字的乘法表
num = int(input('请输入要实现n乘法表：'))
for i in range(1,num+1) :
    for j in range(1,i+1) :
        print('%s*%s=%s' % (i,j,i*j),end='\t')
    print()

打印象棋
for i in range(9) :
    for j in range(9):
        if (i+j+1)%2 :
            print('\033[40;1m  \033[0m',end='')
        else:
            print('  ',end='')
    print()

列表解析
•  它是一个非常有用、简单、而且灵活的工具,可以用来动态地创建列表
•  语法:
  [expr for iter_var in iterable]	
•  这个语句的核心是for循环,它迭代iterable对象的所有条目
•  expr应用于序列的每个成员,最后的结果值是该表达式产生的列表

[10+5]
[10+5 for i in range(10)]
[10+i for i in range(10)]
[10+i for i in range(10) if i % 2 == 1]
[10+i for i in range(10) if i % 2]
['192.168.1.%s' % i for i in range(1,20)]

文件对象

文件打开方法

open及file内建函数
•  作为打开文件之门的“钥匙”,内建函数open()以及
file()提供了初始化输入/输出(I/O)操作的通用接口
•  成功打开文件后时候会返回一个文件对象,否则引发一个错误
•  open()方法和file()方法可以完全相互替换
•  基本语法:
file_object	= open(file_name,	access_mode='r',	buffering=-1)	


文件对象访问模式
文件模式		操作
r 			以读方式打开(文件不存在则报错)
w 			以写方式打开(文件存在则清空,不存在则创建)
a 			以追加模式打开(必要时创建新文件)
r+ 			以读写模式打开(参见r)
w+ 			以读写模式打开(参见w)
a+ 			以读写模式打开(参见a)
b 			以二进制模式打开

文件操作的三个步骤：打开、读写、关闭

read方法
•  read()方法用来直接读取字节到字符串中,最多读取给定数目个字节，把所有内容读取出来
•  如果没有给定size参数(默认值为-1)或者size值为负,文件将被读取直至末尾
>>> data = fobj.read()	
>>> print(data)

readline方法
•  读取打开文件的一行(读取下个行结束符之前的所有字节)
•  然后整行,包括行结束符,作为字符串返回
•  它也有一个可选的size参数,默认为-1,代表读至行结束符
•  如果提供了该参数,那么在超过size个字节后会返回不完整的行
>>> data = fobj.readline()	
>>> print(data)	

readlines方法
•  readlines()方法读取所有(剩余的)行然后把它们作为一个字符串列表返回
>>>	data	= fobj.readlines()	
>>>	print(data)	


随着读写的进行，文件指针向后移动。
因为第一个f.read()已经把文件指针移动到结尾了，所以再读就没有数据了
所以再执行data = f.read()时，这里为空

>>> f = open('/tmp/passwd')
>>> data = f.read()
>>> print(data)
>>> f.close()
硬盘的一个block 在分区后，默认是4k 也就是4096个字节
所以在读取的时候，建议使用 f.read(4096)

f = open('/tmp/passwd')
data = f.read(4)  # 读4字节
f.readline()  # 读到换行符\n结束
f.readlines()  # 把每一行数据读出来放到列表中
f.close()



文件迭代
•  如果需要逐行处理文件,可以结合for循环迭代文件
•  迭代文件的方法与处理其他序列类型的数据类似
>>>	fobj	= open('star.py')	
>>>	for eachLine in fobj:	
--		print(eachLine, end='')	

f = open('/tmp/passwd')
for line in f:
    print(line,end='')    因为默认read的时候每行都有\n换行，所以这里把print默认的换行取消就可以了
f.close()

#######################################
f = open('图片地址', 'rb')  # 打开非文本文件要加参数b
f.read(4096)
f.close()




文件输出

write方法

•  write()内建方法功能与read()和readline()相反。它把含有文本数据或二进制数据块的字符串写入到文件中去
•  写入文件时,不会自动添加行结束标志,需要程序员手工输入
>>> fobj.write('Hello World!\n')	
13

writelines方法
•  和readlines()一样,writelines()方法是针对列表的操作
•  它接受一个字符串列表作为参数,将它们写入文件
•  行结束符并不会被自动加入,所以如果需要的话,必须在调用writelines()前给每行结尾加上行结束符
>>>	fobj.writelines(['Hello	World!\n', 'python programing\n'])	


f = open('/tmp/myfile','w')	#以w打开文件，如果文件不存在则创建
f.write('hello world\n')
f.flush()				#立即将缓存中的数据同步到磁盘
f.writelines(['2nd line.\n','new line.\n'])
f.close()				#关闭文件的时候，数据保存到磁盘



with子句
•  with语句是用来简化代码的
•  在将打开文件的操作放在with语句中,代码块结束后,文件将自动关闭
>>> with open('foo.py') as f:	
...    data = f.readlines()	
...
>>>	f.closed	
True


with open('/tmp/passwd') as f :
    print(f.readline())

文件内移动
•  seek(offset[, whence]):移动文件指针到不同的位
–  offset是相对于某个位置的偏移量
–  whence的值,0表示文件开头,1表示当前位置,2表示文件的结尾
•  tell():返回当前文件指针的位置
如果要使用seek的调用，需要在打开文件时，使用 'rb' 方式打开


>>> f = open('/tmp/passwd') 
>>> f.tell()
0
>>> f.read()
>>> f.tell()
2525
>>> f.seek(0,0)
0
>>> f.readline()
>>> f.tell()
142
>>> f.close

××××××××××××××××
>>> f = open('/tmp/hosts','rb')
>>> f.seek(-2,2)
569
>>> f.seek(1,1)
570
>>> f.seek(3,0)
3
>>> f.tell()
3






标准文件
•  程序一执行,就可以访问三个标准文件
–  标准输入:一般是键盘,使用sys.stdin
–  标准输出:一般是显示器缓冲输出,使用sys.stdout
–  标准错误:一般是显示器的非缓冲输出,使用
sys.stderr
>>>	import sys	
>>>	sys.stdout.write('hello	world!\n')	
hello	world!	
>>>	hi = sys.stdin.readline()	
hello	
>>>	hi
'hello\n'	使用input没有\n

>>> sys.stdout.write('haha\n')	#print自带\n
haha
5
>>> sys.stderr.write('haha\n')
haha
5
在命令行界面运行的时候， 上面一个可以  使用 > file
下面一个可以使用 2> file



案例3:模拟cp操作
1.  创建cp.py文件
2.  将/bin/ls“拷贝”到/root/目录下
3.  不要修改原始文件

src_fname = '/bin/ls'
dst_fname = '/root/ls'

src_fobj = open(src_fname,'rb')	因为是二进制文件，要加上b
dst_fobj = open(dst_fname,'wb')

while True :
    data = src_fobj.read(4096)		一个block是4096，每次都读这么大，防止文件过大占用资源
    if not data :				当data都读完了时，是空的，not data就是 True，然后跳出
        break
    dst_fobj.write(data)

src_fobj.close()
dst_fobj.close()


函数基本操作

函数基本概念
•  函数是对程序逻辑进行结构化或过程化的一种编程方
•  将整块代码巧妙地隔离成易于管理的小块
•  把重复代码放到函数中而不是进行大量的拷贝,这样既能节省空间,也有助于保持一致性
•  通常函数都是用于实现某一种功能

创建函数
•  函数是用def语句来创建的,语法如下:
def funcOon_name(arguments):	
    "funcOon_documentaOon_string"	
    funcOon_body_suite	
•  标题行由def关键字,函数的名字,以及参数的集合(如果有的话)组成
•  def子句的剩余部分包括了一个虽然可选但是强烈推荐的文档字串,和必需的函数体

id()查看()内的内存地址


def gen_fib() :
    fib=[0,1]
    num = int(input('请输入一个数字： '))
    for i in range(len(fib),num) :
        fib.append(fib[i-2] + fib[i-1])
    print(fib)

gen_fib()

调用函数
•  同大多数语言相同,python用一对圆括号调用函数
•  如果没有加圆括号,只是对函数的引用


函数的返回值
•  多数情况下,函数并不直接输出数据,而是向调用者返回值
•  函数的返回值使用return关键字
•  没有return的话,函数默认返回None

def gen_fib() :
    fib=[0,1]
    num = int(input('请输入一个数字： '))
    for i in range(len(fib),num) :
        fib.append(fib[i-2] + fib[i-1])
    return fib  #返回变量的值，不返回变量名字
a = gen_fib()
print(a)
print(gen_fib())


定义参数
•  形式参数
–  函数定义时,紧跟在函数名后(圆括号内)的参数被称为形式参数,简称形参。由于它不是实际存在变量,
所以又称虚拟变量
•  实际参数
–  在主调函数中调用一个函数时,函数名后面括弧中的参数(可以是一个表达式)称为“实际参数”,简称实参

传递参数
•  调用函数时,实参的个数需要与形参个数一致
•  实参将依次传递给形参
在定义函数时，尽量不要使用input，尽量使用传参，因为数据的输入不一样是从键盘，也可以从文件或者其他

>>>	def foo(x,y):	
...	  print('x=%d, y=%d' % (x, y))	
>>>	foo()	
Traceback	(most	recent call last):	
		File	"<stdin>", line 1, in <module>	
TypeError:	foo()	takes	exactly 2 arguments (0 given)	
>>>	foo(3)
Traceback (most recent call last):	
		File	"<stdin>", line 1, in <module>	
TypeError:	foo()	takes	exactly 2 arguments (1 given)	
>>>	foo(3, 4)	
x=3,	y=4	



def mtable(n):
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            print('%s*%s=%s' % (j, i, i * j), end=' ')
        print()

mtable(6)
mtable(9)



位置参数
•  与shell脚本类似,程序名以及参数都以位置参数的方式传递给python程序
•  使用sys模块的argv列表接收
position_args.py

import sys
print(sys.argv)

[root@room9pc01 python]# python3 position_args.py 
['position_args.py']
[root@room9pc01 python]# python3 position_args.py 1
['position_args.py', '1']
[root@room9pc01 python]# python3 position_args.py 1 jlasf
['position_args.py', '1', 'jlasf']
[root@room9pc01 python]# python3 position_args.py 1 jlasf 10
['position_args.py', '1', 'jlasf', '10']

默认参数
•  默认参数就是声明了默认值的参数
•  因为给参数赋予了默认值,所以在函数调用时,不向该参数传入值也是允许的

>>> def pstar(n=50) :
...     print('*' * n)
... 
>>> pstar()
**************************************************
>>> pstar(30)
******************************

将函数的位置变量加进去
copy.py

import sys
def copy (src_fname,dst_fname) :

    src_fobj = open(src_fname,'rb')
    dst_fobj = open(dst_fname,'wb')

    while True :
        data = src_fobj.read(4096)
        if not data :
            break
        dst_fobj.write(data)

    src_fobj.close()
    dst_fobj.close()
copy(sys.argv[1],sys.argv[2])

[root@room9pc01 python]# python3 copy.py /tmp/haha /tmp/xx 


模块基础

定义模块
模块基本概念
•  模块是从逻辑上组织python代码的形式
•  当代码量变得相当大的时候,最好把代码分成一些有组织的代码段,前提是保证它们的彼此交互
•  这些代码片段相互间有一定的联系,可能是一个包含数据成员和方法的类,也可能是一组相关但彼此独立的操作函数

创建模块
•  模块物理层面上组织模块的方法是文件,每一个以.py作为结尾的python文件都是一个模块
•  模块名称切记不要与系统中已存在的模块重名
•  模块文件名字去掉后面的扩展名(.py)即为模块名

star.py

hi = 'hello world'
def pstar(n=50) :
    print('*' * n)

call_star.py

import star
print(star.hi)
star.pstar()
star.pstar(30)
[root@room9pc01 python]# python3 call_star.py 
hello world
**************************************************
******************************


•  使用import导入模块
•  模块被导入后,程序会自动生成pyc的字节码文件以提升性能
•  模块属性通过“模块名.属性”的方法调用
•  如果仅需要模块中的某些属性,也可以单独导入
>>>	import sys	
>>>	import os, string	
>>>	string.digits	
'0123456789'	
>>>	from random import randint	
>>>	randint(1,10)	
3	


模块加载(load)
•  一个模块只被加载一次,无论它被导入多少次
•  只加载一次可以阻止多重导入时代码被多次执行
•  如果两个文件相互导入,防止了无限的相互加载
•  模块加载时,顶层代码会自动执行,所以只将函数放入模块的顶层是良好的编程习惯

模块导入的特性
•  模块具有一个__name__特殊属性
•  当模块文件直接执行时,__name__的值为'__main__'
•  当模块被另一个文件导入时,__name__的值就是该模块的名字

foo.py

def pstar(n=50) :
    print('*' * n)
if __name__ == '__main__':		这里如果不加，那么在import foo时，会再执行一遍
    pstar()
    pstar(30)

[root@room9pc01 python]# python3 foo.py 
**************************************************
******************************

>>> import foo
>>> 



案例4:生成随机密码
•  创建randpass.py脚本,要求如下:
1.  编写一个能生成8位随机密码的程序
2.  使用random的choice函数随机取出字符
3.  改进程序,用户可以自己决定生成多少位的密码


import random
import sys
A = '1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'
def cpasswd(n=8) :
    passwd = ''
    for i in range(n) :
        passwd += random.choice(A)
    return passwd
if __name__ == '__main__':
    if len(sys.argv) != 1:
        print(cpasswd(int(sys.argv[1])))
    else:
        print(cpasswd())


string的模块可以查看详细信息

import string      
A = string.ascii_letters + string.digits

在pytcharm 里按住ctrl 点击对应的超链接，可以看到调用的模块的代码

调用 randpasspy
>>> import randpass
>>> randpass.cpasswd(3)
'22X'
>>> randpass.cpasswd(4)
'ChLM'









shell相关模块

shutil模块

复制和移动
•  shutil.copyfileobj(fsrc, fdst[, length])
将类似文件的对象fsrc的内容复制到类似文件的对象fdst。
•  shutil.copyfile(src, dst, *, follow_symlinks=True)
将名为src的文件的内容(无元数据)复制到名为dst的文件,然后返回dst。

•  shutil.copy(src, dst, *, follow_symlinks=True)
将文件src复制到文件或目录dst。src和dst应为字符串。
如果dst指定目录,则文件将使用src的基本文件名复制到dst中。返回新创建的文件的路径。
•  shutil.copy2(src, dst, *, follow_symlinks=True)
与copy()相同,但copy2()也尝试保留所有文件元数据。
•  shutil.move(src, dst, copy_function=copy2)
递归地将文件或目录(src)移动到另一个位置(dst),并返回目标。

目录操作
•  shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)
递归地复制以src为根的整个目录树,返回目标目录。由dst命名的目标目录不能已经存在。
•  shutil.rmtree (path, ignore_errors=False, onerror=None)
删除整个目录树; 路径必须指向目录(而不是指向目录的符号链接)。


import shutil

with open('/etc/passwd','rb') as sfobj:
    with open('/tmp/mima.txt','wb') as dfobj:
        shutil.copyfileobj(sfobj,dfobj)         #拷贝文件对象

shutil.copyfile('/etc/passwd', '/tmp/mima2.txt')    # cp 1.txt 2.txt
shutil.copy('/etc/shadow', '/tmp/')                 # cp 1.txt /root/
shutil.copy2('/etc/shadow', '/tmp/')                # cp -p 1.txt /root/
shutil.move('/tmp/mima.txt', '/var/tmp')            # mv a.txt /root/
shutil.copytree('/var/log', '/tmp/logs')            # cp -r /var/log /tmp/logs
shutil.rmtree('tmp/logs')                           # rm -rf /tmp/logs


权限管理
•  shutil.copymode(src, dst, *, follow_symlinks=True)
将权限位从src复制到dst。文件内容,所有者和组不受影响。src和dst是以字符串形式给出的路径名称。
•  shutil.copystat(src, dst, *, follow_symlinks=True)
将权限位,最后访问时间,上次修改时间和标志从src复制到dst。
•  shutil.chown(path, user=None, group=None)
更改给定路径的所有者用户和/或组

###将mima2.txt的权限设置成与/etc/shadow一样 
shutil.copymode('/etc/shadow','/tmp/mima2.txt')

###将mima2.txt的元数据设置成与/etc/shadow一样，元数据使用stat /etc/shadow 查看
shutil.copystat('/etc/shadow','/tmp/mima2.txt')

shutil.chown('/tmp/passwd',user='zhangsan',group='zhangsan')


pycharm的code选项  Reformat Code 会自动调整空格和空白行


>>> a = b = 10
>>> id(a)
9336192
>>> id(b)
9336192
>>> a = 20
>>> b
10
>>> id(a)
9336512
>>> id(b)
9336192
>>> alist = blist = [1,2,3]
>>> alist[0] = 10
>>> alist
[10, 2, 3]
>>> blist
[10, 2, 3]
>>> id(alist)
140402769182024
>>> id(blist)
140402769182024

因为数值是不可变类型，列表是可变类型，a重新赋值 是在内存中开辟了另一块空间
alist 重新赋值是在原来的内存空间进行修改


语法风格

变量赋值
•  python支持链式多重赋值
x = y = 10
•  另一种将多个变量同时赋值的方法称为多元赋值,采用这种方式赋值时,等号两边的对象都是元组
a, b = 10, 20


合法标识符
•  python标识符字符串规则和其他大部分用C编写的高级语言相似
•  第一个字符必须是字母或下划线(_)
•  剩下的字符可以是字母和数字或下划线
•  大小写敏感

关键字
•  和其他的高级语言一样,python也拥有一些被称作关键这字的保留字符
•  任何语言的关键字应该保持相对的稳定,但是因为python是一门不断成长和进化的语言,其关键字偶尔会更新
•  关键字列表和iskeyword()函数都放入了keyword模块以便查阅

内建
•  除了关键字之外,python还有可以在任何一级代码使用的“内建”的名字集合,这些名字可以由解释器设置或使用
•  虽然built-in不是关键字,但是应该把它当作“系统保留字”
•  保留的常量如:True、False、None

模块结构及布局
•  编写程序时,应该建立一种统一且容易阅读的结构,并将它应用到每一个文件中去
#!/usr/bin/env python			#起始行
“this is a test module”     #模块文档字符串
import sys			#导入模块
import os 
debug = True	#全局变量声明
class	FooClass(object):		#类定义
    'Foo class'	
   pass	
def test():    #函数定义
"test	funcDon"	
 foo	= FooClass()	
if __name__	== ‘__main__’:	 #程序主体
  test()	

案例1:创建文件
1.  编写一个程序,要求用户输入文件名
2.  如果文件已存在,要求用户重新输入
3.  提示用户输入数据,每行数据先写到列表中
4.  将列表数据写入到用户输入的文件名中

先建立逻辑，把程序的逻辑列出来

import os

def get_fname() :
    while True :
        fname = input('filename: ')
        if not os.path.exists(fname) :
            break
        print('%s already exists. Try again' % fname)
    return fname
def get_content() :
    content = []
    print('输入数据，输入end结束')
    while True :
        line = input('> ')
        if line == 'end' :
            break
        content.append(line)
    return  content

def wfile(fname,content) :
    with open(fname,'w') as fobj :
        fobj.writelines(content)

if __name__ == '__main__':
    fname = get_fname()
    content = get_content()
    content = ['%s\n' % line for line in content]
    wfile(fname,content)




字符串详解


序列类型操作符

序列操作符		作用
seq[ind] 		获得下标为ind的元素
seq[ind1:ind2] 	获得下标从ind1到ind2间的元素集合
seq * expr 		序列重复expr次
seq1 + seq2 	连接序列seq1和seq2
obj in seq 		判断obj元素是否包含在seq中
obj not in seq 	判断obj元素是否不包含在seq中

内建函数
函 数			含 义
list(iter) 		把可迭代对象转换为列表
str(obj) 		把obj对象转换成字符串
tuple(iter) 	把一个可迭代对象转换成一个元组对象


•  len(seq):返回seq的长度
•  max(iter,key=None):返回iter中的最大值
•  enumerate:接受一个可迭代对象作为参数,返回一个enumerate对象

from random import randint

alist = list()  # []
list('hello')  # ['h', 'e', 'l', 'l', 'o']
list((10, 20, 30))  # [10, 20, 30]  元组转列表
astr = str()  # ''
str(10)  # '10'
str(['h', 'e', 'l', 'l', 'o'])  # 将列表转成字符串
atuple = tuple()  # ()
tuple('hello')  # ('h', 'e', 'l', 'l', 'o')
num_list = [randint(1, 100) for i in range(10)]
max(num_list)
min(num_list)


alist = [10,'john']
>>> list(enumerate(alist))
[(0, 10), (1, 'john')]
>>> for ind in range(len(alist)) :
...   print('%s:%s' % (ind,alist[ind]))
... 
0:10
1:john
>>> for item in enumerate(alist) :
...   print('%s:%s'%(item[0],item[1]))
... 
0:10
1:john
>>> for ind,val in enumerate(alist) :
...   print('%s:%s'%(ind,val))
... 
0:10
1:john

•  reversed(seq):接受一个序列作为参数,返回一个以逆序访问的迭代器
•  sorted(iter):接受一个可迭代对象作为参数,返回一个有序的列表

>>> atuple = [randint(1,100) for i in range(10)]
>>> atuple
[29, 23, 31, 93, 29, 23, 61, 73, 5, 16]
>>> sorted(atuple)
[5, 16, 23, 23, 29, 29, 31, 61, 73, 93]
>>> reversed(atuple)
<list_reverseiterator object at 0x7fb2112f20f0>
>>> list(reversed(atuple))
[16, 5, 73, 61, 23, 29, 93, 31, 23, 29]
>>> for i in reversed(atuple) :
...   print(i,end=' ')
... 
16 5 73 61 23 29 93 31 23 29


字符串

字符串操作符
•  比较操作符:字符串大小按ASCII码值大小进行比较
•  切片操作符:[ ]、[ : ]、[ : : ]
•  成员关系操作符:in、not in
>>>	py_str = 'Hello World!'	
>>>	py_str[::2]
'HloWrd'	
>>>	py_str[::-1]	
'!dlroW olleH'



案例2:检查标识符
1.  程序接受用户输入
2.  判断用户输入的标识符是否合法
3.  用户输入的标识符不能使用关键字
4.  有不合法字符,需要指明第几个字符不合法


import keyword
keyword.kwlist  # 关键字列表
keyword.iskeyword('pass')  # 判断pass是不是关键字




import string
import keyword
import sys

first_char = string.ascii_letters + '_'
all_char = string.digits + first_char

def check_id(char) :
    if char[0] not in first_char :
        return "1st is invalid!"
    if keyword.iskeyword(char) :
        return '%s is keyword' % char
    for i in enumerate(char) :
        if i[1] not in all_char :
            return '第%s个字符不合法！！！' % (i[0]+1)
    return '%s is valid' % char

if __name__ == '__main__':
    print(check_id(sys.argv[1]))


格式化操作符
•  字符串可以使用格式化符号来表示特定含义
格式化字符		转换方式
%c 			转换成字符
%s 			优先用str()函数进行字符串转换
%d / %i 		转成有符号十进制数
%o 			转成无符号八进制数    %#o
%e / %E 		转成科学计数法
%f / %F 		转成浮点数


"%s is %s years old" % ('bob', 23)  # 常用
"%s is %d years old" % ('bob', 23)  # 常用
"%s is %d years old" % ('bob', 23.5)  # %d是整数 常用
"%s is %f years old" % ('bob', 23.5)
"%s is %5.2f years old" % ('bob', 23.5)  # %5.2f是宽度为5，2位小数
"97 is %c" % 97	#转换成ascii
"11 is %#o" % 11  # %#o表示有前缀的8进制
"11 is %#x" % 11
"%10s%5s" % ('name', 'age')  # %10s表示总宽度为10，右对齐, 常用
"%10s%5s" % ('bob', 25)
"%10s%5s" % ('alice', 23)
"%-10s%-5s" % ('name', 'age')  # %-10s表示左对齐, 常用
"%-10s%-5s" % ('bob', 25)
"%10d" % 123
"%010d" % 123

"{} is {} years old".format('bob', 25)
"{1} is {0} years old".format(25, 'bob')
"{:<10}{:<8}".format('name', 'age')





•  字符串可以使用格式化符号来表示特定含义
辅助指令		作用
* 			定义宽度或者小数点精度
- 			左对齐
+ 			在正数前面显示加号
<sp>	 		在正数前面显示空格
#			在八进制数前面显示零0,在十六进制前面显示'0x'或者'0X'
0 			显示的数字前面填充0而不是默认的空格


format函数
•  使用位置参数
–  'my name is {} ,age {}'.format('hoho',18)
•  使用关键字参数
–  'my name is {name},age is
{age}'.format({'name':'bob', 'age':23})
•  填充与格式化
–  {:[填充字符][对齐方式 <^>][宽度]}
•  使用索引
–  'name is {0[0]} age is {0[1]}'.format(['bob', 23])
前面的0 代表format括号里的第一个项目



案例3:创建用户
1.  编写一个程序,实现创建用户的功能
2.  提示用户输入用户名
3.  随机生成8位密码
4.  创建用户并设置密码
5.  将用户相关信息写入指定文件

import subprocess
import sys
from randpass import cpasswd
def adduser(username, passwd, fname) :
    data = '''user information:
%s : %s
'''
    subprocess.call('useradd %s' % username,shell=True)
    subprocess.call(
        'echo %s | passwd --stdin %s' % (passwd, username),
        shell=True
    )
    with open(fname,'a') as fobj:
        fobj.write(data % (username, passwd))

if __name__ == '__main__':
    adduser(sys.argv[1],cpasswd(8),'/tmp/user.txt')



原始字符串操作符
•  原始字符串操作符是为了对付那些在字符串中出现的特殊字符
•  在原始字符串里,所有的字符都是直接按照字面的意思来使用,没有转义特殊或不能打印的字符
>>>	winPath = "c:\windows\temp"	
>>>	print(winPath)	
c:\windows emp	
>>>	newPath = r"c:\windows\temp"	
>>>	print(newPath)	
c:\windows\temp	

案例4:格式化输出
1.  提示用户输入(多行)数据
2.  假定屏幕的宽度为50,用户输入的多行数据如下显
示(文本内容居中):
+************************************************
+			helloworld			+	
+			greatwork!			+	
+************************************************+	


py_str = 'hello world!'
py_str.capitalize()
Hello world!		这里字符串本身不会变，因为字符串本身不变

py_str.title()
Hello World!

py_str.center(50)
py_str.center(50, '#')
py_str.ljust(50, '*')
py_str.rjust(50, '*')
**************************************hello world!
py_str.count('l')  # 统计l出现的次数
py_str.count('lo')
py_str.endswith('!')  # 以!结尾吗？
py_str.endswith('d!')
py_str.startswith('a')  # 以a开头吗？
py_str.islower()  # 字母都是小写的？其他字符不考虑
py_str.isupper()  # 字母都是大写的？其他字符不考虑
'Hao123'.isdigit()  # 所有字符都是数字吗？
'Hao123'.isalnum()  # 所有字符都是字母数字？
'  hello\t    '.strip()  # 去除两端空白字符，常用
'  hello\t    '.lstrip()
'  hello\t    '.rstrip()
'how are you?'.split()
'hello.tar.gz'.split('.')
'.'.join(['hello', 'tar', 'gz'])
'-'.join(['hello', 'tar', 'gz'])



列表和元组


创建及访问列表
•  列表是有序、可变的数据类型
•  列表中可以包含不同类型的对象
•  列表可以由[]或工厂函数创建
•  支持下标及切片操作

a = b = 10
a = 20  # b的值不变，因为数字是不可变的

alist = blist = [1, 2]
alist[0] = 10  # blist也会改变，因为列表是可变的

更新列表
•  通过下标只能更新值,不能使用标添加新值
>>>	alist	= [10, 35, 20, 80]	
>>>	alist[-1] = 100	
>>>	alist[1:3] = [30,	50]	
>>> alist[2:2]
[]
>>> alist[2:2] = [11,22,33,44]
>>> alist
[10, 35, 11, 22, 33, 44, 20, 80]

列表内建函数
列表方法			操作
list.append(obj) 		向列表中添加一个对象obj
list.count(obj) 		返回一个对象obj 在列表中出现的次数
list.extend(seq) 		把序列seq的内容添加到列表中
list.index(obj) 		返回obj对象的下标
list.insert(index, obj) 	在索引量为index 的位置插入对象obj
list.reverse() 		原地翻转列表
list.sort() 		排序


alist = [1, 2, 3, 'bob', 'alice']
alist[0] = 10
alist[1:3] = [20, 30]
alist[2:2] = [22, 24, 26, 28]
alist.append(100)
alist.remove(24)  # 删除第一个24
alist.index('bob')  # 返回第一个bob的下标
blist = alist.copy()  # 相当于blist = alist[:]
alist.insert(1, 15)  # 向下标为1的位置插入数字15
alist.pop()  # 默认弹出最后一项
alist.pop(2) # 弹出下标为2的项目
alist.pop(alist.index('bob'))
alist.sort()
alist.reverse()
alist.count(20)  # 统计20在列表中出现的次数
alist.clear()  # 清空
alist.append('new')
alist.extend('new')
alist.extend(['hello', 'world', 'hehe'])

元组
创建元组
•  通过()或工厂函数tuple()创建元组
•  元组是有序的、不可变类型
•  与列表类似,作用于列表的操作,绝大数也可以作用于元组

单元素的元组
a = (10)  使用type 查看这是一个数值
应该这样写
a = (10,)

“更新”元组
•  虽然元组本身是不可变的,但是因为它同时属于容器
类型,也就意味着元组的某一个元素是可变的容器类
型,那么这个元素中的项目仍然可变


案例5:用列表构建栈结构
1.  栈是一个后进先出的结构
2.  编写一个程序,用列表实现栈结构
3.  需要支持压栈、出栈、查询功能

先考虑行为：交互/非交互
再考虑功能，写成函数
最后主程序



def push_it() :			\

def pop_it() :			 |

def view_it() :			 |>===========>    先写主结构

def show_menu() :			 |

if __name__ == '__main__':	 |

    show_menu()			/



def show_menu() :
    cmds = {'0': push_it, '1': pop_it, '2': view_it}		里面的函数不能有()
    promt = '''(0) push it
(1) pop it
(2) view it
(3) exit
Please input your choice(0/1/2/3)'''

    while True :
        # input()得到字符串,用strip()去除两端空白,再取下标为0的字符
        choice = input(promt).strip()[0]
        if choice not in '0123' :
            print('Invalid input. Try again')
            continue
        if choice == '3' :
            break
        cmds[choice]()					#######类似于shell里面的case语句

完整格式：

stack = []

def push_it() :
    item = input('item to push: ')
    stack.append(item)

def pop_it() :
    if stack :
        print('from stack popped %s' % stack.pop())

def view_it() :
    print(stack)

def show_menu() :
    cmds = {'0': push_it, '1': pop_it, '2': view_it}
    promt = '''(0) push it
(1) pop it
(2) view it
(3) exit
Please input your choice(0/1/2/3)'''

    while True :
        # input()得到字符串,用strip()去除两端空白,再取下标为0的字符
        choice = input(promt).strip()[0]
        if choice not in '0123' :
            print('Invalid input. Try again')
            continue
        if choice == '3' :
            break
        cmds[choice]()

if __name__ == '__main__':
    show_menu()





Python开发进阶


字典和集合

字典基础操作

创建字典
•  通过{ }操作符创建字典
•  通过dict()工厂方法创建字典
•  通过fromkeys()创建具有相同值的默认字典

访问字典
•  字典是映射类型,意味着它没有下标,访问字典中的
值需要使用相应的键


更新字典
•  通过键更新字典
–  如果字典中有该键,则更新相关值
–  如果字典中没有该键,则向字典中添加新值
>>> adict = dict()
>>> adict
{}

>>> dict(['ab','cd'])
{'a': 'b', 'c': 'd'}

>>> bdict = dict([('name','bob'),('age',43)])
>>> bdict
{'name': 'bob', 'age': 43}

>>> {}.fromkeys(['zhangsan','kusu','bob'],11)
{'zhangsan': 11, 'kusu': 11, 'bob': 11}

>>> for key in bdict :
...     print('%s:%s' % (key,bdict[key]))
... 
name:bob
age:43

>>> print('%(name)s:%(age)s' % bdick)
bob:43

>>> bdick['name'] = 'tom'
>>> bdick
{'name': 'tom', 'age': 43}
>>> bdick['email'] = 'tom@tedu.cn'
>>> bdick
{'name': 'tom', 'age': 43, 'email': 'tom@tedu.cn'}


删除字典
•  通过del可以删除字典中的元素或整个字典
•  使用内部方法clear()可以清空字典
•  使用pop()方法可以“弹出”字典中的元素
>>> del adict['email’]	
>>> print(adict)	
{'age': 22, 'name': 'bob’}	
>>> adict.pop('age’)	
22	
>>> print(adict)	
{'name':'bob’}	
>>> adict.clear()	
>>> print(adict)	
{}	


字典操作符
•  使用字典键查找操作符[ ],查找键所对应的值
•  使用in和not in判断键是否存在于字典中
>>> adict = {'age': 23, 'name': 'bob'}	
>>> print(adict['name’])	
Bob
>>> 'bob' in adict	
False
>>> 'name' in adict	
True	


字典相关函数

作用于字典的函数
•  len():返回字典中元素的数目
•  hash():本身不是为字典设计的,但是可以判断某个对象是否可以作为字典的键
字典内建方法
•  dict.copy():返回字典(深复制)的一个副本
•  dict.get(key, default=None):对字典dict中的键
key,返回它对应的值value,如果字典中不存在此键,则返回default的值
•  dict.setdefault(key, default=None):如果字典中不存在key键,由dict[key]=default为它赋值
•  dict.items():返回一个包含字典中(键,值)对元组的列表
•  dict.keys():返回一个包含字典中键的列表
•  dict.values():返回一个包含字典中所有值的列表
•  dict.update(dict2):将字典dict2的键-值对添加到字典dict


>>> adict = dict([('name','bob'),('age','23')])
>>> adict
{'name': 'bob', 'age': '23'}
>>> len(adict)
2
>>> hash(10)  # 判断给定的数据是不是不可变的，不可变数据才能作为key
10
>>> hash('10')
-8525507676581654654
>>> hash([1,2])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> adict.keys()
dict_keys(['name', 'age'])
>>> adict.values()
dict_values(['bob', '23'])
>>> adict.items()
dict_items([('name', 'bob'), ('age', '23')])

# get方法常用，重要

>>> adict.get('name')
'bob'
>>> print(adict.get('qq'))  # 取出字典中name对应的value，如果没有返回None
None
>>> print(adict.get('qq','not found'))
not found
>>> print(adict.get('age','not found'))
23
>>> adict.update({'name':'job'})
>>> adict
{'name': 'job', 'age': '23'}
>>> adict.update({'phone':'1234124124'})
>>> adict
{'name': 'job', 'age': '23', 'phone': '1234124124'}


案例1:模拟用户登陆信息系统
1.  支持新用户注册,新用户名和密码注册到字典中
2.  支持老用户登陆,用户名和密码正确提示登陆成功
3.  主程序通过循环询问进行何种操作,根据用户的选择,执行注册或是登陆操作

import getpass

userdb = {}
menu = '''you can do follows：
(0) register
(1) login
(2) exit
Please input your choice(0/1/2): '''

def register() :
    username = input('username： ')
    if username in userdb :
        print('%s already exists' % username)
    else:
        passwd = input('passwd： ')
        userdb[username] = passwd

def login() :
    username = input('username： ')
    passwd = getpass.getpass("passwd： ")
    if userdb.get(username) != passwd :
        print('login failed!')
    else:
        print('login successful!')

def show_menu() :
    while True :
        cmds = {'0': register, '1': login, '2': exit}
        choice = input(menu).strip()[0]
        if choice not in '012' :
            print('Invalid input. Try again.')
            continue
        cmds[choice]()

if __name__ == '__main__':
    show_menu()


案例2:编写unix2dos的程序
1.  Windows文本文件的行结束标志是\r\n
2.  类unix文本文件的行结束标志是\n
3.  编写程序,将unix文本文件格式转换为windows文
本文件的格式

import sys

def unix2dos(fname):
    dst_fname = fname + '.txt'

    with open(fname) as src_fobj:
        with open(dst_fname, 'w') as dst_fobj:
            for line in src_fobj:
                line = line.rstrip() + '\r\n'
                dst_fobj.write(line)


if __name__ == '__main__':
    unix2dos(sys.argv[1])



显示10秒计时，且后面显示的会替换掉前面的

import time
import sys

for i in range(10) :
    print('\r %s' % i ,end='')
    sys.stdout.flush()
    time.sleep(1)

案例3:编写类进度条程序
1.  在屏幕上打印20个#号
2.  符号@从20个#号穿过
3.  当@符号到达尾部,再从头开始

import time

lenth = 19
count = 0

while  True :
    if count == lenth +1:
        count = 0
    print('\r%s@%s' % ('#'* count,'#'*(lenth-count)),end='')
    count += 1
    time.sleep(1)




集合

创建集合
•  数学上,把set称做由不同的元素组成的集合,集合(set)的成员通常被称做集合元素
•  集合对象是一组无序排列的可哈希的值
•  集合有两种类型
–  可变集合set
–  不可变集合frozenset


# 集合相当于是无值的字典，所以也用{}表示
myset = set('hello')
len(myset)
for ch in myset:
    print(ch)

aset = set('abc')
bset = set('cde')
aset & bset  # 交集
aset.intersection(bset)  # 交集
aset | bset  # 并集
aset.union(bset)  # 并集
aset - bset  # 差补
aset.difference(bset)  # 差补
aset.add('new')
aset.update(['aaa', 'bbb'])
aset.remove('bbb')
cset = set('abcde')
dset = set('bcd')
cset.issuperset(dset)  # cset是dset的超集么？
cset.issubset(dset)  # cset是dset的子集么？






运用的set集合的不重复性，进行比较


案例： 比对2个大文件的不同的部分
file1     file2

with open('file1') as fobj :
    aset = set(fobj)

with open('file2') as fobj :
    bset = set(fobj)

with open('diff.txt','w') as fobj :
    fobj.writelines(bset - aset)





time模块

时间表示方式
•  时间戳timestamp:表示的是从1970年1月1日00:00:00开始按秒计算的偏移量
•  UTC(Coordinated Universal Time,世界协调时)亦即格林威治天文时间,世界标准时间。
在中国为UTC+8。DST(Daylight Saving Time)即夏令时
•  元组(struct_time):由9个元素组成

struct_time元组
索引 		属性 				值
0 		tm_year 			2000
1 		tm_mon 			1-12
2 		tm_mday 			1-31
3 		tm_hour 			0-23
4 		tm_min 			0-59
5 		tm_sec 			0-61
6 		tm_wday 			0-6(0表示周一)
7 		tm_yday(一年中的第几天) 	1-366
8 		tm_isdst(是否为dst时间) 	默认为-1

time模块方法
•  time.localtime([secs]):将一个时间戳转换为当前时区的struct_time。secs参数未提供,则以当前时间为准
•  time.gmtime([secs]):和localtime()方法类似,
gmtime()方法是将一个时间戳转换为UTC时区(0时区)的struct_time
•  time.time():返回当前时间的时间戳
•  time.mktime(t):将一个struct_time转化为时间戳
•  time.sleep(secs):线程推迟指定的时间运行。单位为秒
•  time.asctime([t]):把一个表示时间的元组或者struct_time表示为
这种形式:‘Sun Jun 2023:21:05 1993’。如果没有参数,将会将time.localtime()作为参数传入
•  time.ctime([secs]):把一个时间戳(按秒计算的浮点数)转化为time.asctime()的形式
•  time.strftime(format[, t]):把一个代表时间的元组或者struct_time(如由time.localtime()和
time.gmtime()返回)转化为格式化的时间字符串。如果t未指定,将传入time.localtime()
•  time.strptime(string[, format]):把一个格式化时间字符串转化为struct_time。
实际上它和strftime()是逆操作
>>>time.strftime('%Y-%m-%d %X', time.localtime())	
'2017-12-12 12:58:19'	

时间样式
格式	含义					格式		含义
%a 	本地简化星期名称 			%m 		月份(01-12)
%A 	本地完整星期名称 			%M 		分钟数(00-59)
%b 	本地简化月份名称 			%p 		本地am或者pm的相应符
%B	本地完整月份名称 			%S 		秒(01-61)
%c 	本地相应的日期和时间 			%U 		一年中的星期数(00–53,星期日是一个星期的开始)
%d 	一个月中的第几天(01-31) 		%w 		一个星期中的第几天(0-6,0是星期天)
%H	一天中的第几个小时(24小时制,00-23)	%x 		本地相应日期
%I 	第几个小时(12小时制,01-12) 		%X 		本地相应时间
%j 	一年中的第几天(001-366) 		%y 		去掉世纪的年份(00-99)
%Z 	时区的名字				%Y		完整的年份


查看某个程序的运行时间
import time

result = 0
start = time.time()
for i in range(10000000):
    result += i
end = time.time()
print(result)
print(end - start)


import time

t = time.localtime()  # 返回当前时间的九元组
time.gmtime()  # 返回格林威治0时区当前时间的九元组
time.time()  # 常用，与1970-1-1 8:00之间的秒数，时间戳
time.mktime(t)  # 把九元组时间转成时间戳
time.sleep(1)
time.asctime()  # 如果有参数，是九元组形式
time.ctime()  # 返回当前时间，参数是时间戳，常用
time.strftime("%Y-%m-%d") # 常用
time.strptime('2018-07-20', "%Y-%m-%d")  # 返回九元组时间格式
time.strftime('%H:%M:%S')

###########################################
from datetime import datetime
from datetime import timedelta
datetime.today()  # 返回当前时间的datetime对象
datetime.now()  # 同上，可以用时区作参数
datetime.strptime('2018/06/30', '%Y/%m/%d')  # 返回datetime对象
dt = datetime.today()
datetime.ctime(dt)
datetime.strftime(dt, "%Y%m%d")

days = timedelta(days=90, hours=3)  # 常用
dt2 = dt + days
dt2.year
dt2.month
dt2.day
dt2.hour








datetime模块

•  datetime.today():返回一个表示当前本地时间的datetime对象
•  datetime.now([tz]):返回一个表示当前本地时间的datetime对象,
如果提供了参数tz,则获取tz参数所指时区的本地时间
•  datetime.strptime(date_string, format):将格式字符串转换为datetime对象
•  datetime.ctime(datetime对象):返回时间格式字符串
•  datetime.strftime(format):返回指定格式字符串

时间计算
•  使用timedelta可以很方便的在日期上做天days,小
时hour,分钟,秒,毫秒,微妙的时间计算
>>> dt = datetime.datetime.now()	
>>> days = datetime.timedelta(days=100, hours=3)	
>>> dt + days	
datetime.datetime(2050, 6, 10,	20, 41, 20, 106546)	










异常处理

什么是异常
•  当python检测到一个错误时,解释器就会指出当前
流已经无法继续执行下去,这时候就出现了异常
•  异常是因为程序出现了错误而在正常控制流以外采取
的行为
•  这个行为又分为两个阶段:
–  首先是引起异常发生的错误
–  然后是检测(和采取可能的措施)阶段


python中的异常
•  当程序运行时,因为遇到未解的错误而导致中止运行,
便会出现traceback消息,打印异常
异常			描述
NameError 		未声明/初始化对象
IndexError 		序列中没有没有此索引
SyntaxError 	语法错误
KeyboardInterrupt	用户中断执行
EOFError 		没有内建输入,到达EOF标记
IOError 		输入/输出操作失败

try-except语句
•  定义了进行异常监控的一段代码,并且提供了处理异常的机制
try:	
    try_suite  #监控这里的异常
except Exception[as reason]:	
    except_suite	#异常处理代码
>>> try:	
... f = open('foo.txt')	
... except FileNotFoundError:	
...    print('No such file')	
...
No such file	




带有多个expect的try语句
•  可以把多个except语句连接在一起,处理一个try块中可能发生的多种异常


try:
    n = int(input('number:  '))
    result = 100/n
    print(result)

except ZeroDivisionError :
    print('0 not allowed')
except ValueError:
    print('invalid number')
except KeyboardInterrupt:
    print('byebye')
except EOFError :
    print('byebye')
    
print('done')



try:
    n = int(input('number:  '))
    result = 100/n
    print(result)


except (ValueError,ZeroDivisionError):
    print('invalid number')
except (KeyboardInterrupt,EOFError):
    print('\nbyebye')

print('done')



try:
    n = int(input("number: "))
    result = 100 / n
except (ValueError, ZeroDivisionError):
    print('invalid number')
except (KeyboardInterrupt, EOFError):
    print('\nBye-bye')
else:
    print(result)  # 异常不发生时才执行else子句
finally:
    print('Done')  # 不管异常是否发生都必须执行的语句

# 常用形式有try-except和try-finally


raise语句
•  要想引发异常,最简单的形式就是输入关键字raise,
后面跟要引发的异常的名称
•  执行raise语句时,Python会创建指定的异常类的一个对象
•  raise语句还可指定对异常对象进行初始化的参数

断言
•  断言是一句必须等价于布尔值为真的判定
•  此外,发生异常也意味着表达式为假


案例5:自定义异常
1.  编写第一个函数,函数接收姓名和年龄,如果年龄
不在1到120之间,产生ValueError异常
2.  编写第二个函数,函数接收姓名和年龄,如果年龄
不在1到120之间,产生断言异常



def set_age(name, age):
    if not 0 < age < 120:
        raise ValueError('年龄超过范围')
    print("%s is %d years old" % (name, age))

def set_age2(name, age):
    assert 0 < age < 120, '年龄超过范围'
    print("%s is %d years old" % (name, age))

if __name__ == '__main__':
    set_age('zhangsan', 20)
    set_age2('lisi', 200)


OS相关模块

import os

os.getcwd()  # 显示当前路径
os.listdir()  # ls -a
os.listdir('/tmp')  # ls -a /tmp
os.mkdir('/tmp/mydemo')  # mkdir /tmp/mydemo
os.chdir('/tmp/mydemo')  # cd /tmp/mydemo
os.listdir()
os.mknod('test.txt')  # touch test.txt
os.symlink('/etc/hosts', 'zhuji')  # ln -s /etc/hosts zhuji
os.path.isfile('test.txt')  # 判断test.txt是不是文件
os.path.islink('zhuji')  # 判断zhuji是不是软链接
os.path.isdir('/etc')
os.path.exists('/tmp')  # 判断是否存在
os.path.basename('/tmp/abc/aaa.txt') #返回aaa.txt
os.path.dirname('/tmp/abc/aaa.txt')	#获取当前文件的上一层目录'/tmp/abc'
os.path.split('/tmp/abc/aaa.txt')	#('/tmp/abc', 'aaa.txt')
os.path.join('/home/tom', 'xyz.txt')
os.path.abspath('test.txt')  # 返回当前目录test.txt的绝对路径



pickle模块


pickle模块简介
•  把数据写入文件时,常规的文件方法只能把字符串对象写入。其他数据需先转换成字符串再写入文件 。
•  python提供了一个标准的模块,称为pickle。使用它可以在一个文件中储存任何python对象,
之后又可以把它完整无缺地取出来


import pickle
"""以前的文件写入，只能写入字符串，如果希望把任意数据对象(数字、列表等)写入文件，
取出来的时候数据类型不变，就用到pickle了
"""

# shop_list = ["eggs", "apple", "peach"]
# with open('/tmp/shop.data', 'wb') as fobj:
#     pickle.dump(shop_list, fobj)

with open('/tmp/shop.data', 'rb') as fobj:
    mylist = pickle.load(fobj)

print(mylist[0], mylist[1], mylist[2])


案例7:记账程序
1.  假设在记账时,有一万元钱
2.  无论是开销还是收入都要进行记账
3.  记账内容包括时间、金额和说明等
4.  记账数据要求永久存储

自己写的

import pickle
import time

atime = time.strftime("%Y%m%d")
menu = '''(0) 收入记账
(1) 开销记账
(2) 查询
(3) 退出
请输入你的选择(0/1/2/3)'''
def income() :
    money = int(input('收入金额（元）：  '))
    comment = input('说明： ')
    with open('/tmp/wallet','rb') as fobj :
        balance = pickle.load(fobj)
    balance += money
    with open('/tmp/wallet','wb') as fobj :
        pickle.dump(balance,fobj)
    with open('/tmp/account_book','a') as fobj :
        fobj.writelines([atime,'\t',str(money),'\t0\t',str(balance),'\t',comment,'\n'])
def custom() :
    money = int(input('开销金额（元）：  '))
    comment = input('说明： ')
    with open('/tmp/wallet','rb') as fobj :
        balance = pickle.load(fobj)
    balance -= money
    with open('/tmp/wallet','wb') as fobj :
        pickle.dump(balance,fobj)
    with open('/tmp/account_book','a') as fobj :
        fobj.writelines([atime,'\t','0\t',str(money),'\t',str(balance),'\t',comment,'\n'])

def select() :
    with open('/tmp/account_book') as fobj :
        print(fobj.read())
def show_menu() :
    cmds = {'0': income, '1': custom, '2': select, '3': exit}
    while True:
        choice = input(menu).strip()[0]
        if choice not in '0123' :
            print('输入有误,请重试')
            continue
        cmds[choice]()
if __name__ == '__main__':
    show_menu()



老师：

先写框架：

import pickle
import os
import time

def cost(wallet,record) :
    amount = int(input('amount: '))
    comment = input('comment:  ')
    date = time.strftime('%Y-%m-%d')
    with open(wallet, 'rb') as fobj :
        balance = pickle.load(fobj) - amount
    with open(wallet,'wb') as fobj :
        pickle.dump(balance,fobj)
    with open(record,'a') as fobj :
        fobj.write(
            '%-12s%-8s%-8s%-10s%-20s\n' % (date,amount,'',balance,comment)
        )

def save(wallet,record) :
    amount = int(input('amount: '))
    comment = input('comment:  ')
    date = time.strftime('%Y-%m-%d')
    with open(wallet, 'rb') as fobj :
        balance = pickle.load(fobj) + amount
    with open(wallet,'wb') as fobj :
        pickle.dump(balance,fobj)
    with open(record,'a') as fobj :
        fobj.write(
            '%-12s%-8s%-8s%-10s%-20s\n' % (date,'',amount,balance,comment)
        )

def query(wallet,record) :
    print('%-12s%-8s%-8s%-10s%-20s' % ('date','cost','save','balance','comment'))
    with open(record) as fobj :
        for line in fobj :
            print(line,end='') #fobj打开的是带有\n的,print默认也有\n,所以这也要去掉一个\n
    with open(wallet,'rb') as fobj :
        balance = pickle.load(fobj)
    print('Latest Balance: %d' % balance)


def show_menu() :
    cmds = {'0': cost, '1': save, '2': query}
    promt = '''(0) cost 
(1) save
(2) query
(3) exit
Please input your choice(0/1/2/3):'''
    wallet = 'wallet.data'
    record = 'record.txt'
    if not os.path.exists(wallet) :
        with open(wallet,'wb') as fobj :
            pickle.dump(10000,fobj)

    while True:
        try :
            choice = input(promt).strip()[0]
        except IndexError :
            continue
        except (KeyboardInterrupt,EOFError) :
            print()
            choice = '3'

        if choice not in '0123' :
            print('Invalid input.Try again.')
            continue
        if choice == '3' :
            break
        cmds[choice](wallet,record)

if __name__ == '__main__':
    show_menu()







































Python开发进阶

创建函数

def 语句
•  函数用def语句创建,语法如下:
def func(on_name(arguments):	
	"func(on_documenta(on_string"	
	func(on_body_suite	
•  标题行由def关键字,函数的名字,以及参数的集合(如果有的话)组成
•  def子句的剩余部分包括了一个虽然可选但是强烈推荐的文档字串,和必需的函数体前向引用
•  函数不允许在函数未声明之前对其进行引用或者调用内部函数
•  在函数体内创建另外一个函数是完全合法的,这种函数叫做内部/内嵌函数


调用函数

函数操作符
•  使用一对圆括号()调用函数,如果没有圆括号,只是
对函数的引用
•  任何输入的参数都必须放置在括号中

func_args.py

def get_age(name, age):
    print('%s is %s years old' % (name, age))

get_age('bob', 25)  # 参数按顺序传递
get_age(25, 'bob')
get_age(age=25, name='bob')
# get_age()  # Error，少参数
# get_age('bob', 25, 100)  # Error，多参数
# get_age(age=25, 'bob')  # 语法错误
# get_age(25, name='bob')  # 错误，参数按顺序传递，name得到多个值
get_age('bob', age=25)

关键字参数
•  关键字参数的概念仅仅针对函数的调用
•  这种理念是让调用者通过函数调用中的参数名字来区分参数
•  这样规范允许参数缺失或者不按顺序

参数组
•  python允许程序员执行一个没有显式定义参数的函数
•  相应的方法是通过一个把元组(非关键字参数)或字
典(关键字参数)作为参数组传递给函数

tuple_args.py

def func1(*args): # *表示args是个元组
	print(args)

def func2(**kwargs): ## ** 表示kwargs是个字典
	print(kwargs)
def func3(x, y):
	print(x * y)

def func4(name,age):
	print('%s is %s years old' % (name, age))
if __name__ == '__main__':
	func1()
	func1(10)
	func1(10,'bob')
	func2()
	func2(name='bob', age=25)
	func3(*[10,5]) #调用的时候,* 表示拆开后面的数据类型
	func4(**{'name':'bob', 'age': 25}) # name='bob', age=25

案例1:简单的加减法数学游戏
1.  随机生成两个100以内的数字
2.  随机选择加法或是减法
3.  总是使用大的数字减去小的数字
4.  如果用户答错三次,程序给出正确答案


from random import randint,choice

def add(x,y):
    return x+y
def sub(x,y):
    return x-y
def exam():
    cmds = {'+':add, '-':sub}
    nums = [randint(1,100) for i in range(2)]
    nums.sort(reverse=True)
    op = choice('+-')
    result = cmds[op](*nums)
    prompt = '%s %s %s = ' % (nums[0],op,nums[1])
    tries = 0

    while tries < 3:
        try :
            answer = int(input(prompt))
        except :
            continue

        if answer == result :
            print('very good!')
            break
        else:
            print('wrong answer.')
            tries += 1
    else:
        print('correct answer is %s' % result)

if __name__ == '__main__':
    while True:
        exam()
        try:
            yn = input('Continue(y/n)?').strip()[0]
        except IndexError:
            continue
        except (KeyboardInterrupt,EOFError):
            print()
            yn = 'n'
        if yn in 'nN':
            break

匿名函数

•  python允许用lambda关键字创造匿名函数
•  匿名是因为不需要以标准的def方式来声明
•  一个完整的lambda“语句”代表了一个表达式,这
个表达式的定义体必须和声明放在同一行
lambda [arg1[, arg2, ... argN]]: expression
>>> a = lambda x, y: x+y	
>>>	print(a(3, 4))	
7

from random import randint,choice

def exam():
    cmds = {'+':lambda x,y:x+y, '-':lambda x,y:x-y}
    nums = [randint(1,100) for i in range(2)]
    nums.sort(reverse=True)
    op = choice('+-')
    result = cmds[op](*nums)
    prompt = '%s %s %s = ' % (nums[0],op,nums[1])
    tries = 0

    while tries < 3:
        try :
            answer = int(input(prompt))
        except :
            continue

        if answer == result :
            print('very good!')
            break
        else:
            print('wrong answer.')
            tries += 1
    else:
        print('%s%s' % (prompt, result))


if __name__ == '__main__':
    while True:
        exam()
        try:
            yn = input('Continue(y/n)?').strip()[0]
        except IndexError:
            continue
        except (KeyboardInterrupt,EOFError):
            print()
            yn = 'n'
        if yn in 'nN':
            break



filter()函数
•  filter(func, seq):调用一个布尔函数func来迭代遍历
每个序列中的元素;返回一个使func返回值为true的
元素的序列
•  如果布尔函数比较简单,直接使用lambda匿名函数
就显得非常方便了
>>> data = filter(lambda	x: x % 2, [num for num in range(10)])	
>>>	print(data)	#过滤出10以内的奇数
[1, 3, 5, 7, 9]	


from random import randint

def func1(x):
    return x % 2

if __name__ == '__main__':
    alist = [randint(1, 100) for i in range(10)]
    print(alist)
    # filter要求第一个参数是函数，该函数必须返回True或False
    # 执行时把alist的每一项作为 func1的参数，返回真留下，否则过滤掉
    result = filter(func1, alist)  # 高阶函数
    print(list(result))
    result2 = filter(lambda x: x % 2, alist)
    print(list(result2))


map() 函数


from random import randint

def func1(x):
    return x*2+1

if __name__ == '__main__':
    alist = [randint(1, 100) for i in range(10)]
    print(alist)
    # map将第二个参数中的每一项交给fucnc函数进行加工，保留加工后的结果
    result = map(func1, alist)  # 高阶函数
    print(list(result))
    result2 = map(lambda x: x * 2 + 1, alist)
    print(list(result2))



函数高级应用

变量作用域

全局变量
•  标识符的作用域是定义为其声明在程序里的可应用范围,也就是变量的可见性
•  在一个模块中最高级别的变量有全局作用域
•  全局变量的一个特征是除非被删除掉,否则它们的存活到脚本运行结束,且对于所有的函数,
他们的值都是可以被访问的


局部变量
•  局部变量只时暂时地存在,仅仅只依赖于定义它们的函数现阶段是否处于活动
•  当一个函数调用出现时,其局部变量就进入声明它们的作用域。在那一刻,一个新的局部变量名为那个对象创建了
•  一旦函数完成,框架被释放,变量将会离开作用域
•  如果局部与全局有相同名称的变量,那么函数运行时,局部变量的名称将会把全局变量名称遮盖住

>>> x = 4	
>>> def foo():	
... x = 10	
... print('in foo, x =', x)	
...	
>>> foo()	
in foo, x = 10	
>>> print('in main, x =', x)	
in main, x = 4	


global语句
•  因为全局变量的名字能被局部变量给遮盖掉,所以为了明确地引用一个已命名的全局变量,必须使用global语句

>>>x=4	
>>>def foo():	
... globalx	
... x = 10	
... print('in foo, x =', x)	
...	
>>> foo()	
in foo, x = 10	
>>> print('in main, x =', x)	
in main, x = 10	


>>> def bbb():
...    print(len('haha'))
... 
>>> 
>>> bbb()
4
>>> len =100
>>> bbb()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in bbb
TypeError: 'int' object is not callable
>>> def ccc() :
...   len = 50
...   print(len)
... 
>>> ccc()
50


名字空间
•  任何时候,总有一个到三个活动的作用域(内建、全局和局部)
•  标识符的搜索顺序依次是局部、全局和内建
•  提到名字空间,可以想像是否有这个标识符
•  提到变量作用域,可以想像是否可以“看见”这个标识符
变量的识别 顺序    局部变量==>全局变量==>内建函数

函数式编程



偏函数
•  偏函数的概念是将函数式编程的概念和默认参数以及可变参数结合在一起
•  一个带有多个参数的函数,如果其中某些参数基本上固定的,那么就可以通过偏函数为这些参数赋默认值

>>> from operator	import add	
>>> from functools import par(al	
>>> add10 = par(al(add, 10)	
>>> print(add10(25))	
35	


from functools import partial
def foo(a, b, c, d, e):
    return a + b + c + d +e
if __name__ == '__main__':
    print(foo(10,20,30,40,5))
    print(foo(10,20,30,40,25))
    print(foo(10,20,30,40,69))
    print(foo(10,20,30,40,33))
    add = partial(foo,a=10,b=20,c=30,d=40)
    print(add(e=5))
    print(add(e=25))

案例2:简单GUI程序
1.  窗口程序提供三个按钮
2.  其中两个按钮的前景色均为白色,背景色为蓝色
3.  第三个按钮前景色为红色,背景色为红色
4.  按下第三个按钮后,程序退出

import tkinter
from functools import partial

root = tkinter.Tk()
lb = tkinter.Label(text='hello world!')
b1 = tkinter.Button(root, fg='white', bg='blue', text='Button 1')
MyBtn = partial(tkinter.Button,root, fg='white', bg='blue')
b2 = MyBtn(text='Button 2')
b3 = MyBtn(text='quit', command =root.quit)
lb.pack()
b1.pack()
b2.pack()
b3.pack()
root.mainloop()

#yum -y install tk-devel tcl-devel sqlite-devel


递归函数
•  如果函数包含了对其自身的调用,该函数就是递归的
•  在操作系统中,查看某一目录内所有文件、修改权限等都是递归的应用
>>> def func(num):	
...    if num == 1:	
...          return 1	
...	 else:	
...		return num * func(num - 1)	
...	
>>> print(func(5))	
120	
>>> print(func(10))	
3628800	

def func(n):  # 5
    if n == 1:
        return n
    return n * func(n - 1)
         # 5 * func(4)
         # 5 * 4 * func(3)
         # 5 * 4 * 3 * func(2)
         # 5 * 4 * 3 * 2 * func(1)
         # 5 * 4 * 3 * 2 * 1

if __name__ == '__main__':
    print(func(5))
    print(func(6))



案例3:快速排序
1.  随机生成10个数字
2.  利用递归,实现快速排序


from random import randint

def quick_sort(num_list):
    if len(num_list) < 2 :
        return num_list
    middle = num_list[0]
    smaller = []
    larger = []
    for i in num_list[1:] :
        if i < middle :
            smaller.append(i)
        else:
            larger.append(i)
    return quick_sort(smaller) + [middle] + quick_sort(larger)


if __name__ == '__main__':
    alist = [randint(1,100) for i in range(10)]
    print(quick_sort(alist))


生成器
•  从句法上讲,生成器是一个带yield语句的函数
•  一个函数或者子程序只返回一次,但一个生成器能暂停执行并返回一个中间的结果
•  yield 语句返回一个值给调用者并暂停执行
•  当生成器的next()方法被调用的时候,它会准确地从离开地方继续




def mygen() :
	yield 'hello'
	a = 10+5
	yield a		每个yield运行到这就停一下
	yield [1,2,3]

if __name__ == '__main__':
    m = mygen()
    for i in m :
        print(i)
    for i in m :
        print(i)  #无值，因为生成器对象只能用一次

每次读取10行文件，然后遍历读出所有内容

def blocks(fobj) :
    block = []
    count = 0
    for line in fobj:
        block.append(line)
        count +=1
        if count == 10 :
            yield block		#返回中间结果，下次取值，从这里继续执行
            block = []
            count = 0
    if block :
        yield block

if __name__ == '__main__':
    fobj = open('/tmp/passwd')
    for lines in blocks(fobj) :
        print(lines)
        print()
    fobj.close()




内部函数

闭包
•  闭包将内部函数自己的代码和作用域以及外部函数的作用结合起来
•  闭包的词法变量不属于全局名字空间域或者局部的--而属于其他的名字空间,带着“流浪"的作用域
•  闭包对于安装计算,隐藏状态,以及在函数对象和作用域中随意地切换是很有用的
•  闭包也是函数,但是他们能携带一些额外的作用域

1、函数中嵌套定义了另一个函数
2、内嵌函数引用了外部函数的变量
3、外部函数返回内嵌函数


import tkinter
from functools import partial

def hello(words) :
    def welcome() :
        lb.config(text= 'hello %s!' % words)
    return welcome          #hello函数的返回值还是函数

root = tkinter.Tk()
lb = tkinter.Label(text='hello world!',font = 'Times 26')
MyBtn = partial(tkinter.Button,root, fg='white', bg='blue')
b1 = MyBtn(text='Button 1',command=hello('china')) #command的返回值只能是函数，所以在hello里面再嵌套
b2 = MyBtn(text='Button 2',command=hello('tedu'))
b3 = MyBtn(text='quit', command =root.quit)
lb.pack()
b1.pack()
b2.pack()
b3.pack()
root.mainloop()


•  创建通用的计数器
def counter(start=0):
    count = start
    def incr():
        nonlocal count
        count += 1
        return count
    return incr

if __name__ == '__main__':
    a = counter()
    print(a())
    b = counter(10)
    print(b())
    print(a())
    print(b())

装饰器
•  装饰器是在函数调用之上的修饰
•  这些修饰仅是当声明一个函数或者方法的时候,才会应用的额外调用
•  使用装饰器的情形有:
–  引入日志
–  增加计时逻辑来检测性能
–  给函数加入事务的能力



def color(func) :
    def red():
        return '\033[31;1m%s\033[0m' % func()
    return red


def hello() :
    return  'hello World'

@color
def welcome() :
    return  'hello China'

if __name__ == '__main__':
    hello = color(hello) # 此种写法可以换成为welcome加上@color
    print(hello())
    print(color(welcome)())
    print(welcome())       #welcome 因为有装饰器，所以调用时不是调用welcome函数
                           #而是相当于color(welcome)()
                           #color(welcome)返回red,color(welcome)()
                           #等价于red()








def color(func) :
    def red(*args):
        return '\033[31;1m%s\033[0m' % func(*args)
    return red

@color
def hello(word) :
    return  'hello %s' % word

@color
def welcome() :
    return  'hello China'

if __name__ == '__main__':
    print(hello('World'))
    print(welcome())


案例4:测试程序运行效率
1.  有个程序包含多个函数
2.  程序运行耗时较长
3.  为了确定哪个函数是瓶颈,需要计算出每个函数运行时间
4.  要求使用装饰器实现

案例：仿照ls -R的功能写一个递归的函数






Python开发进阶

模块和文件

什么是模块
•  模块支持从逻辑上组织python代码
•  当代码量变得相当大的时候, 最好把代码分成一些有组织的代码段
•  代码片段相互间有一定的联系,可能是一个包含数据成员和方法的类,也可能是一组相关但彼此独立的操作函数
•  这些代码段是共享的,所以python允许“调入”一个模块,允许使用其他模块的属性来利用之前的工作成果,实现代码重用

•  说模块是按照逻辑来组织python代码的方法,文件是物理层上组织模块的方法
•  一个文件被看作是一个独立模块,一个模块也可以被看作是一个文件
•  模块的文件名就是模块的名字加上扩展名.py


名称空间
•  名称空间就是一个从名称到对象的关系映射集合
•  给定一个模块名之后,只可能有一个模块被导入到python解释器中,所以在不同模块间不会出现名称交叉现象
•  每个模块都定义了它自己的唯一的名称空间
>>>	import foo
>>>	import bar	
>>>	print(foo.hi) #调用foo模中的hi变量
hello	
>>>	print(bar.hi) #调用bar模块中的hi变量
greet	


导入模块

搜索路径
•  模块的导入需要一个叫做“路径搜索”的过程
•  python在文件系统“预定义区域”中查找要调用的模块
•  搜索路径在sys.path中定义
>>> import sys	
>>> print(sys.path)	
['', '/usr/local/lib/python36.zip',	'/usr/local/lib/python3.6',	'/usr/
local/lib/python3.6/lib-dynload',	'/usr/local/lib/python3.6/site-
packages']


模块导入方法
•  使用import导入模块
•  可以在一行导入多个模块,但是可读性会下降
•  可以只导入模块的某些属性
•  导入模块时,可以为模块取别名
>>>	import time, os, sys	
>>>	from random import choice	
>>>	import pickle as p	

•  当导入模块时,模块的顶层代码会被执行
•  一个模块不管被导入(import)多少次,只会被加载(load)一次
[root@py01 ~]# cat foo.py	
hi = 'hello'	
print(hi)	
[root@py01	~]# python3	
>>> import foo	
Hello			#第一次导入,执行print语句
>>> import foo	 #再次导入,print语句不再执行	

从zip文件中导入
•  在2.3版中,python加入了从ZIP归档文件导入模块的功能
•  如果搜索路径中存在一个包含python模块(.py、.pyc、或.pyo文件)的.zip文件,
导入时会把ZIP文件当作目录处理
#导入sys模块,在搜索路径中加入相应的zip文件	
>>> import sys		
>>> sys.path.append('/root/pymodule.zip')	
>>> import foo    #导入pymodule.zip压缩文件中的foo模块

import sys  
import string as s # 导入模块时，可以取别名

sys.path #模块导入时搜索的路径，自己写的模块可以放到site-packages
s.ascii_letters

# foo.py -> hi = 'hello'
	     #print(hi)
#zip mytest.zip foo.py
#rm -rf foo.py
#python3

#>>> import foo ->Error
#>>> import sys
#>>> sys.path.append('./mytest.zip')
#>>> import foo



包

目录结构
•  包是一个有层次的文件目录结构,为平坦的名称空间加入有层次的组织结构
•  允许程序员把有联系的模块组合到一起
•  包目录下必须有一个__init__.py文件
phone/	
	__init__.py	
	common_uDl.py	
	voicedata/	
		__init__.py	
		post.py	



绝对导入
•  包的使用越来越广泛,很多情况下导入子包会导致和真正的标准库模块发生冲突
•  因此,所有的导入现在都被认为是绝对的,也就是说这些名字必须通过python路径(sys.path或PYTHONPATH)来访问

相对导入
•  绝对导入特性使得程序员失去了import的自由,为此出现了相对导入
•  因为import语句总是绝对导入的,所以相对导入只
应用于from-import语句
[root@py01	~]# ls -R phone/	
phone/:
common_util.py __init__.py voicedata	
phone/voicedata:
__init__.py	 post.py	
	
[root@py01 ~]# cat phone/voicedata/post.py	
from .. import common_util	


内置模块

hashlib模块
•  hashlib用来替换md5和sha模块,并使他们的API一致,专门提供hash算法
•  包括md5、sha1、sha224、sha256、sha384、sha512,使用非常简单、方便
>>>	import hashlib	
>>>	m = hashlib.md5()	
>>>	m.update('hello world!')	
>>>	m.hexdigest()	
'fc3ff98e8c6a0d3087d515c0473f8677'	


>>> m.update('hello world')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Unicode-objects must be encoded before hashing
>>> m.update('hello world'.encode('utf8'))
>>> print(m.hexdigest())
202cb962ac59075b964b07152d234b70





#加密：对称加密、非对称加密、单向加密
#单向加密：加密只能向一个方向进行，相同的数据总是得到相同的"乱码"
#不能根据结果回推源。用途：文件完整性、加密密码

import hashlib

f = open('/etc/passwd', 'rb')
data = f.read()
f.close()

m = hashlib.md5(data)
print(m.hexdigest())

# m = hashlib.md5()
# m.update(data)  # 每次读取一部分文件内容，更新至m对象


类似于md5sum的功能

import sys
import hashlib

def check_md5(file) :
     m = hashlib.md5()
     with open(file,'rb') as fobj :
         while True :
            data = fobj.read(4096)
            if not  data :
                break
            m.update(data)
     return m.hexdigest()

if __name__ == '__main__':
    print(check_md5(sys.argv[1]))



tarfile模块
•  tarfile模块允许创建、访问tar文件
•  同时支持gzip、bzip2格式
[root@py01	home]# ls /home/demo/	
install.log	 mima	
[root@py01	home]# python	
>>>	import tarfile	
>>>	tar	= tarfile.open('/home/demo.tar.gz', 'w:gz')	
>>>	tar.add('demo')	
>>>	tar.close()	



import tarfile

tar = tarfile.open('/tmp/demo.tar.gz','w:gz')       #gzip压缩
tar.add('/etc/passwd')
tar.add('/etc/hosts')
tar.close()
#tar tvzf /tmp/demo.tar.gz
# https://yiyibooks.cn


tar = tarfile.open('/tmp/demo.tar.gz','r:gz')  # 解压所有文件到当前目录
tar.extractall()			##里面有path 和member的选项功能
tar.close()


案例1:备份程序
1.  需要支持完全和增量备份
2.  周一执行完全备份
3.  其他时间执行增量备份
4.  备份文件需要打包为tar文件并使用gzip格式压缩


OOP基础

基本概念
•  类(Class):用来描述具有相同的属性和方法的对象的集合。
它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
•  实例化:创建一个类的实例,类的具体对象。
•  方法:类中定义的函数。
•  对象:通过类定义的数据结构实例。对象包括两个数据成员(类变量和实例变量)和方法。

创建类
•  使用 class 语句来创建一个新类,class 之后为类的名称并以冒号结尾
•  类名建议使用驼峰形式
class	BearToy:	
	pass	


创建实例
•  类是蓝图,实例是根据蓝图创建出来的具体对象
   tidy = BearToy()	



构造器方法
•  当实例化类的对象时,构造器方法默认自动调用
•  实例本身作为第一个参数,传递给self

class	BearToy:	
	def __init__(self, nm, size, color):
		'''__init__在实例化时自动执行，实例本身自动作为第一个参数传递给self'''
		self.size = size		#绑定属性到实例
		self.color = color	
		self.name = nm
	def sing(self) ；
		print('lalala....')
	def speak(self) :
		print('My name is %s' % self.name)
if __name__ == '__main__':	
	tidy = BearToy('Tiny','small', 'orange')	#调用__init__
	print(tiny.size)
	print(tiny.color)
	tidy.sing()
	tidy.speak()

案例2:编写酒店类
1.  用于计算住宿开销
2.  酒店有会员卡可以打九折
3.  每天早餐15元
4.  根据住宿天数返加总费用

class hotel :
    def __init__(self,price=200,cutoff=1.0, br=15):
        self.price = price
        self.cutoff = cutoff
        self.br = br
    def calc(self,days=1):
        return (self.price * self.cutoff + self.br) * days

if __name__ == '__main__':
    stdroom = hotel()
    bigbed = hotel(220,cutoff=0.9)
    print(stdroom.calc())
    print(stdroom.calc(2))
    print(bigbed.calc())
    print(bigbed.calc(2))


OOP进阶
组合和派生

什么是组合
•  类被定义后,目标就是要把它当成一个模块来使用,并把这些对象嵌入到你的代码中去
•  组合就是让不同的类混合并加入到其它类中来增加功能和代码重用性
•  可以在一个大点的类中创建其它类的实例,实现一些其它属性和方法来增强对原来的类对象

组合应用
•  两个类明显不同
•  一个类是另一个类的组件	

class Vendor:
    def __init__(self, phone, email):
        self.phone = phone
        self.email = email

    def call(self):
        print('calling %s' % self.phone)

class BearToy:
    def __init__(self,color,size,phone,email):
        self.color = color
        self.size = size
        self.vendor = Vendor(phone, email)

if __name__ == '__main__':
    bigbear = BearToy('Brown', 'Middle','4008009999', 'sale@tedu.cn')
    print(bigbear.color)
    bigbear.vendor.call()


创建子类
•  当类之间有显著的不同,并且较小的类是较大的类所需要的组件时组合表现得很好;
但当设计“相同的类但有一些不同的功能”时,派生就是一个更加合理的选择了
•  OOP 的更强大方面之一是能够使用一个已经定义好的类,扩展它或者对其进行修改,
而不会影响系统中使用现存类的其它代码片段
•  OOD(面向对象设计)允许类特征在子孙类或子类中进行继承
•  创建子类只需要在圆括号中写明从哪个父类继承即可

继承
•  继承描述了基类的属性如何“遗传”给派生类
•  子类可以继承它的基类的任何属性,不管是数据属性还是方法


class BearToy :
    def __init__(self,nm, color, size):
        self.name = nm
        self.color = color
        self.size = size
    def sing(self):
        print('lalala.....')
    def speak(self):
        print('my nams is %s' % self.name)

class NewBear(BearToy):
    def run(self):
        print('running...')

if __name__ == '__main__':
    b1 = NewBear('venie','Brown','Large')
    b1.sing()
    b1.run()

通过继承覆盖方法
•  如果子类中有和父类同名的方法,父类方法将被覆盖
•  如果需要访问父类的方法,则要调用一个未绑定的父类方法,明确给出子类的实例

class BearToy :
    def __init__(self,nm, color, size):
        self.name = nm
        self.color = color
        self.size = size
    def sing(self):
        print('lalala.....')
    def speak(self):
        print('my nams is %s' % self.name)

class NewBear(BearToy):
    def __init__(self,nm,color,size,date):
        #BearToy.__init__(self,nm, color, size)
        super(NewBear,self).__init__(nm,color,size)
        self.date = date

    def run(self):
        print('running...')

if __name__ == '__main__':
    b1 = NewBear('venie','Brown','Large','1992-01-01')
    b1.sing()
    b1.run()
    print(b1.date)


多重继承
•  python允许多重继承,即一个类可以是多个父类的子类,子类可以拥有所有父类的属性

class A:
    def foo(self):
        print('in A foo')

class B:
    def bar(self):
        print('in B bar')
class C(A,B):
    pass

if __name__ == '__main__':
    c = C()
    c.foo()
    c.bar()

如果多个父类里有重名的方法，则使用的顺序是：自下向上，自左向右

class A:
    def hello(self):
        print('A hello')

class B:
    def hello(self):
        print('B hello')

class C(B,A):
    pass
    # def hello(self):
    #     print('C hello')

if __name__ == '__main__':
    c.hello()

输出的记过是B hello
如果C 有hello方法，则打印C hello



特殊方法

类方法
•  使用classmethod装饰器定义
•  第一个参数cls表示类本身

静态方法
•  基本上就是一个函数
•  在语法上就像一个方法
•  没有访问对象和它的字段或方法
•  使用staticmethod装饰器定义

class Date :
    def __init__(self,year, month, date):
        self.year = year
        self.month  = month
        self.date  = date

    @classmethod		#类方法，不用创建实例即可调用
    def create(cls,dstr): #cls表示类本身，class
        y, m, d = map(int,dstr.split('-'))
        dt = cls(y, m, d)
        return dt

    @staticmethod				#一个和此类不相关的函数，强行加入此类，要加上静态
    def is_date_valid(dstr):
        y, m, d = map(int,dstr.split('-'))
        return 1<= d <= 31 and 1<= m <=12 and y<4000

if __name__ == '__main__':
    bith_date = Date(1995, 12, 3)
    print(Date.is_date_valid('2000-5-4'))
    day = Date.create('2000-5-4')
    print(day)


__init__方法
•  实例化类实例时默认会调用的方法
class	BearToy:	
	__init__(self, size, color):	
		self.size = size	
		slef.color = color	
	
if __name__ == '__main__':	
	tidy = BearToy('small', 'orange')	


__str__方法
•  打印/显示实例时调用方法
•  返回字符串

__call__方法
•  用于创建可调用的实例

案例3:出版商程序
1.  为出版商编写一个Book类
2.  Book类有书名、作者、页数等属性
3.  打印实例时,输出书名
4.  调用实例时,显示该书由哪个作者编写
class Book:
	def __init__(self, title, author, pages):
		self.title = title
		self.author = author
		self.pages = pages
	def __str__(self):
		return '《 %s 》' % (self.title)
	def __call__(self):
		print('《%s》 is written by %s ' % (self.title,self.author))

if __name__ == '__main__':
	py_book = Book('Core Python', 'Wysley', 800)
	print(py_book)	 #  调用__str__方法 不再显示对象的内存地址，显示 str方法的内容
	py_book()	# 调用__call__方法


1、编写程序,可能将文本文件转成linux文本格式和windows文本格式
2、以OOP的方式编写

import os

class Convert:
    def __init__(self,filename):
        self.filename = filename

    def to_linux(self):
        dst_fname = os.path.splitext(self.filename)[0] + '.linux'
        with open(self.filename) as fobj :
            with open(dst_fname,'w') as dst_fobj :
                for line in fobj :
                    line = line.rstrip() + '\n'
                    dst_fobj.write(line)

    def to_windows(self):
        dst_fname = os.path.splitext(self.filename)[0] + '.windows'
        with open(self.filename) as fobj :
            with open(dst_fname,'w') as dst_fobj :
                for line in fobj :
                    line = line.rstrip() + '\r\n'
                    dst_fobj.write(line)

if __name__ == '__main__':
    A = Convert('/tmp/passwd')
    A.to_linux()
    B = Convert('/tmp/hosts')
    B.to_windows()

××××将属性设置为基本类的属性，将动作或行为设置为方法，尽量不要设置继承子类
××××运用os.path.splitext(文件)，可以将文件名和它的后缀分离,输出为一个元组




























Python开发进阶

DAY04

re模块
正则表达式

匹配单个字符
记号			说 明
. 			匹配任意字符(换行符除外)
[...x-y...]		匹配字符组里的任意字符
[^...x-y...]	匹配不在字符组里的任意字符
\d 			匹配任意数字,与[0-9]同义
\D			匹配非数字
\w 			匹配任意数字字母字符,与[0-9a-zA-Z_]同义
\W			匹配非0-9a-zA-Z_的
\s 			匹配空白字符,与[ \r\v\f\t\n]同义




匹配一组字符
记号			说 明
literal 		匹配字符串的值
re1|re2 		匹配正则表达式re1或re2
* 			匹配前面出现的正则表达式零次或多次
+ 			匹配前面出现的正则表达式一次或多次
? 			匹配前面出现的正则表达式零次或一次
{M, N} 		匹配前面出现的正则表达式至少M次最多N次


其他元字符
记号			说 明
^ 			匹配字符串的开始
$ 			匹配字符串的结尾
\b 			匹配单词的边界
() 			对正则表达式分组
\nn 			匹配已保存的子组

贪婪匹配
•  *、+和?都是贪婪匹配操作符,在其后加上?可以取消其贪婪匹配行为
•  正则表达式匹配对象通过groups函数获取子组
>>>	data = 'My phone number is: 150888899999'	
>>>	m = re.search('.+(\d+)',	data)	
>>>	print	m.groups()
('9',)	
>>>		
>>>	m = re.search('.+?(\d+)', data)	
>>>	m.groups()	
('150888899999',)	

核心函数和方法

match函数
•  尝试用正则表达式模式从字符串的开头匹配,如果匹配成功,则返回一个匹配对象;否则返回None
>>> import re	
>>> m = re.match('foo','food')	 #成功匹配	
>>>	print(m)
<_sre.SRE_Match object; span=(0,3),match='foo'>	
>>>
>>> m = re.match(‘foo’, ‘seafood’)	#未能匹配	
>>>	print(m)	
None	


search函数
•  在字符串中查找正则表达式模式的第一次出现,如果
匹配成功,则返回一个匹配对象;否则返回None
>>>	import re	
>>>	m = re.search('foo', 'food')	
>>>	print(m)	
<_sre.SRE_Match object; span=(0, 3),	match='foo'>	
>>>		
>>>	m	=	re.search(‘foo’,	‘seafood’)						#可以匹配在字符中间的模式	
>>>	print(m)	
<_sre.SRE_Match object; span=(3, 6), match='foo'>	


group方法
•  使用match或search匹配成功后,返回的匹配对象可
以通过group方法获得匹配内容
>>>	import re	
>>>	m = re.match('foo', 'food')	
>>>	print(m.group())	
foo	
	
>>>	m = re.search('foo', 'seafood')	
>>>	m.group()	
'foo'	

findall函数
•  在字符串中查找正则表达式模式的所有(非重复)出现;返回一个匹配对象的列表
>>>	import re	
>>>	m = re.search('foo', 'seafood is food')	
>>>	print(m.group())				#search只匹配模式的第一次出现	
foo	
>>>		
>>>	m = re.findall(‘foo’, ‘seafood is food’)		#获得全部的匹配项	
>>>	print(m)	
['foo',	'foo']	


finditer函数
•  和findall()函数有相同的功能,但返回的不是列表而是迭代器;对于每个匹配,该迭代器返回一个匹配对象
>>>	import re	
>>>	m = re.finditer('foo', 'seafood is food')	
>>>	for item in m:	
...		print(item.group())	
...		
foo	
foo	

compile函数
•  对正则表达式模式进行编译,返回一个正则表达式对象
•  不是必须要用这种方式,但是在大量匹配的情况下,可以提升效率
>>>	import re
>>>	paV = re.compile('foo')	
>>>	m = paV.match('food')	
>>>	print(m.group())	
foo	


split方法
•  根据正则表达式中的分隔符把字符分割为一个列表,
并返回成功匹配的列表
•  字符串也有类似的方法,但是正则表达式更加灵活
>>>	import re #使用.和 -作为字符串的分隔符	
>>>	mylist = re.split('\.|-',	'hello-world.data')	按照指定的符号分离，输出为列表
>>>	print(mylist)	
['hello', 'world','data']

sub方法
•  把字符串中所有匹配正则表达式的地方替换成新的字符串
>>>	import re	
>>>	m = re.sub('X', 'Mr. Smith', 'aVn: X\nDear X')	
>>>	print(m)	
aVn:	Mr. Smith	
Dear	Mr. Smith




import re

m = re.match('f..', 'food')  # 匹配到返回对象
print(re.match('f..', 'seafood'))  # 匹配不到返回None
m.group()  # 返回匹配的值
m = re.search('f..', 'seafood')
m.group()
re.findall('f..', 'seafood is food')  # 返回所有匹配项组成的列表

result = re.finditer('f..', 'seafood is food')  # 返回匹配对象组成的迭代器
for m in result:  # 从迭代器中逐个取出匹配对象
    print(m.group())

re.sub('f..', 'abc', 'fish is food')
re.split('\.|-', 'hello-world.tar.gz')  # 用.和-做切割符号

patt = re.compile('f..')  # 先把要匹配的模式编译，提升效率
m = patt.search('seafood')  # 指定在哪个字符串中匹配
m.group()



案例1:分析apache访问日志
•  编写一个apche日志分析脚本
1.  统计每个客户端访问apache服务器的次数
2.  将统计信息通过字典的方式显示出来
3.  分别统计客户端是Firefox和MSIE的访问次数
4.  分别使用函数式编程和面向对象编程的方式实现


函数式编程
import re

def count_patt(fname,patt):
    result = {}
    cpatt = re.compile(patt)
    
    with open(fname) as fobj :
        for line in fobj:
            m = cpatt.search(line)  #如果匹配不到,返回none
            if m:
                key = m.group()
                result[key] = result.get(key, 0) +1
    return result


if __name__ == '__main__':
    fname = 'access_log'
    ip = '^(\d+\.){3}\d+'
    print(count_patt(fname,ip))
    br = 'Firefox|MSIE|Chrome'
    print(count_patt(fname,br))



面向对象编程

import re
from collections import Counter

class anylize:
    def __init__(self,fname):
        self.fname = fname

    def count_patt(self,patt):
        cpatt = re.compile(patt)
        result = Counter()
        with open(self.fname) as fobj:
            for line in fobj:
                m = cpatt.search(line)
                if m:
                    result.update([m.group()])

        return result

if __name__ == '__main__':
    A=anylize('access_log')
    ip = '^(\d+\.){3}\d+'
    br = 'Firefox|MSIE|Chrome'
    print(A.count_patt(ip).most_common(3))
    print(A.count_patt(br))


completions的Counter模块
>>> c = Counter('abcdeabcdabcaba')  # count elements from a string

    >>> c.most_common(3)                # three most common elements
    [('a', 5), ('b', 4), ('c', 3)]
    >>> sorted(c)                       # list all unique elements
    ['a', 'b', 'c', 'd', 'e']
    >>> ''.join(sorted(c.elements()))   # list elements with repetitions
    'aaaaabbbbcccdde'
    >>> sum(c.values())                 # total of all counts
    15

    >>> c['a']                          # count of letter 'a'
    5
    >>> for elem in 'shazam':           # update counts from an iterable
    ...     c[elem] += 1                # by adding 1 to each element's count
    >>> c['a']                          # now there are seven 'a'
    7
    >>> del c['b']                      # remove all 'b'
    >>> c['b']                          # now there are zero 'b'
    0

    >>> d = Counter('simsalabim')       # make another counter
    >>> c.update(d)                     # add in the second counter
    >>> c['a']                          # now there are nine 'a'
    9

    >>> c.clear()                       # empty the counter
    >>> c
    Counter()

    Note:  If a count is set to zero or reduced to zero, it will remain
    in the counter until the entry is deleted or the counter is cleared:

    >>> c = Counter('aaabbc')
    >>> c['b'] -= 2                     # reduce the count of 'b' by two
    >>> c.most_common()                 # 'b' is still in, but its count is zero
    [('a', 3), ('c', 1), ('b', 0)]


socket模块

什么是C/S架构
•  服务器是一个软件或硬件,用于提供客户需要的“服务”
•  硬件上,客户端常见的就是平时所使用的PC机,服务器常见的有联想、DELL等厂商生产的各种系列服务器
•  软件上,服务器提供的服务主要是程序的运行,数据的发送与接收、合并、升级或其它的程序或数据的操作

套接字
•  套接字是一种具有“通讯端点”概念的计算机网络数据结构
•  套接字起源于20世纪70年代加利福尼亚大学伯克利分校版本的Unix
•  一种套接字是Unix套接字,其“家族名”为AF_UNIX
•  另一种套接字是基于网络的,“家族名”为AF_INET
•  如果把套接字比做电话的插口,那么主机与端口就像区号与电话号码的一对组合

面向连接与无连接
•  无论你使用哪一种地址家族,套接字的类型只有两种。一种是面向连接的套接字,另一种是无连接的套接字
•  面向连接的主要协议就是传输控制协议TCP,套接字类型为SOCK_STREAM
•  无连接的主要协议是用户数据报协议UDP,套接字类型为SOCK_DGRAM
•  python中使用socket模块中的socket函数实现套接字的创建

socket函数与方法
创建TCP服务器
•  创建TCP服务器的主要步骤如下:
1.  创建服务器套接字:s = socket.socket()
2.  绑定地址到套接字:s.bind()
3.  启动监听:s.listen()
4.  接受客户连接:s.accept()
5.  与客户端通信:recv()/send()
6.  关闭套接字:s.close()

import socket

host = ''  # 表示本机所有地址 0.0.0.0
port = 12345  # 应该大于1024
addr = (host, port)
s = socket.socket()  # 默认值就是基于tcp的网络套接字
# 设置选项,程序结束之后可以立即再运行,否则要等60秒
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(addr)  # 绑定地址到套接字
s.listen(1)  # 启动侦听进程
cli_sock, cli_addr= s.accept()
print('Client connect from :', cli_addr)
print(cli_sock.recv(1024))  # 一次最多读1024字节数据
cli_sock.send(b'I 4 C U\r\n')   # 发送的数据要求是bytes类型
cli_sock.close()
s.close()

#yum -y install telnet
#telnet 127.0.0.1 12345




import socket

host = ''  
port = 12345  
addr = (host, port)
s = socket.socket() 
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(addr) 
s.listen(1)  
while True:
    cli_sock, cli_addr= s.accept()
    print('Client connect from :', cli_addr)
    while True:
        data = cli_sock.recv(1024)  
        if data.strip() == b'end' :
            break
        print(data.decode('utf8'))    把bytes类型转换成str类型
        data = input('> ') + '\r\n'		网络数据一般都要加上\r\n
        cli_sock.send(data.encode('utf8'))  把str类型转换成bytes类型
    cli_sock.close()
s.close()


创建TCP客户端
•  创建TCP客户端的步骤主要如下:
1.  创建客户端套接字:cs = socket.socket()
2.  尝试连接服务器:cs.connect()
3.  与服务器通信:cs.send()/cs.recv()
4.  关闭客户端套接字:cs.close()

import socket

host = '192.168.1.254'
port = 12345
addr = (host, port)

c = socket.socket()
c.connect(addr)

while True:
    data = input('> ') + '\r\n'
    c.send(data.encode('utf8'))   #服务器收到end结束,所以要先发送再判断
    if data.strip() == 'end' :
        break
    data = c.recv(1024)
    print(data.decode('utf8'))

c.close()

案例3:创建TCP时间戳服务端


import socket
from time import strftime

class TcpTimeServer:
    def __init__(self, host='', port=12345):
        self.addr = (host, port)
        self.serv = socket.socket()
        self.serv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.serv.bind(self.addr)
        self.serv.listen(1)

    def chat(self, c_sock):
        while True:
            data = c_sock.recv(1024)
            if data.strip() == b'quit':
                break
            data = '[%s] %s' % (strftime('%H:%M:%S'), data.decode('utf8'))
            c_sock.send(data.encode('utf8'))
        c_sock.close()

    def mainloop(self):
        while True:
            cli_sock, cli_addr = self.serv.accept()
            self.chat(cli_sock)

        self.serv.close()

if __name__ == '__main__':
    s = TcpTimeServer()
    s.mainloop()





创建UDP服务器
•  创建UDP服务器的主要步骤如下:
1.  创建服务器套接字:s = socket.socket()
2.  绑定服务器套接字:s.bind()
3.  接收、发送数据:s.recvfrom()/ss.sendto()
4.  关闭套接字:s.close()

import socket
from time import strftime

host = ''
port = 12345
addr = (host, port)
s = socket.socket(type=socket.SOCK_DGRAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(addr)

while True:
    data, cli_addr = s.recvfrom(1024)
    clock = strftime('%H:%M:%S')
    data = data.decode('utf8')
    data = '[%s] %s' % (clock, data)
    s.sendto(data.encode('utf8'), cli_addr)

s.close()






创建UDP客户端
•  创建UDP客户端的步骤主要如下:
1.  创建客户端套接字:cs = socket.socket()
2.  与服务器通信:cs.sendto()/cs.recvfrom()
3.  关闭客户端套接字:cs.close()

import socket

host = '192.168.4.254'
port = 12345
addr = (host, port)

c = socket.socket(type=socket.SOCK_DGRAM)

while True:
    data = input('> ')
    if data.strip() == 'quit':
        break
    c.sendto(data.encode('utf8'), addr)
    print(c.recvfrom(1024)[0].decode('utf8'))
    # print(c.recvfrom(1024))

c.close()





homework


ls -R 递归查找

import os
import sys

def ls_R(path):
    output = os.listdir(path)
    if output:
        print("%s :" % path)
        print('%s\n'% output)
    for i in output:
        newpath = os.path.join(path,i)
        if os.path.isdir(newpath):
            ls_R(newpath)

if __name__ == '__main__':
    path = sys.argv[1]
    ls_R(path)

老师 代码：
import os
import sys

def list_files(path):
    if os.path.isdir(path):
        print(path + ':')
        content = os.listdir(path)
        print(content)
        for fname in content:
            fname = os.path.join(path, fname)
            list_files(fname)

if __name__ == '__main__':
    list_files(sys.argv[1])

案例1:备份程序
1.  需要支持完全和增量备份
2.  周一执行完全备份
3.  其他时间执行增量备份
4.  备份文件需要打包为tar文件并使用gzip格式压缩

import tarfile
import hashlib
import os
from time import strftime

class Backup:
    def __init__(self,fname):
        self.fname = fname
        self.date = strftime('%Y-%m-%d')
        self.week = strftime('%w')
        self.bdir = '/backup/%s' % self.date
        self.bdirmd5 = '/backup/mon.md5'		#

    def fullbackup(self):
        if self.week == '1':
            with tarfile.open('%sfull.tar.gz'% self.bdir,'w:gz') as tar :
                tar.add(self.fname)
            with open(self.bdirmd5, 'a') as fobj:
                for i in os.listdir(self.fname):
                    path = os.path.join(self.fname,i)
                    m = hashlib.md5(path.encode('utf8'))
                    fobj.write('%s\r\n'% m.hexdigest())
    def extrabackup(self):
        if self.week != '1':
            tmp = []
            with open(self.bdirmd5) as fobj:
                for line in fobj:
                    tmp.append(line.strip())
            with tarfile.open('%sextra.tar.gz'% self.bdir,'w:gz') as tar:
                for i in os.listdir(self.fname):
                    path = os.path.join(self.fname,i)
                    mnew = hashlib.md5(path.encode('utf8'))
                    if mnew.hexdigest() not in tmp :
                        tar.add(path)
                        with open(self.bdirmd5, 'a') as fobj:
                            fobj.write('%s\r\n'% mnew.hexdigest())
if __name__ == '__main__':
    backup = Backup('/tmp/httpd') # rm -rf /tmp/*, cp -r /etc/httpd /tmp/
    backup.fullbackup()
    backup.extrabackup()

老师代码：
import time
import os
import tarfile
import hashlib
import pickle

def check_md5(fname):
    m = hashlib.md5()
    with open(fname, 'rb') as fobj:
        while True:
            data = fobj.read(4096)
            if not data:
                break
            m.update(data)
    return m.hexdigest()

def full_backup(src_dir, dst_dir, md5file):
    fname = os.path.basename(src_dir.rstrip('/'))
    fname = '%s_full_%s.tar.gz' % (fname, time.strftime('%Y%m%d'))
    fname = os.path.join(dst_dir, fname)
    md5dict = {}

    tar = tarfile.open(fname, 'w:gz')
    tar.add(src_dir)
    tar.close()

    for path, folders, files in os.walk(src_dir):
        for each_file in files:
            key = os.path.join(path, each_file)
            md5dict[key] = check_md5(key)

    with open(md5file, 'wb') as fobj:
        pickle.dump(md5dict, fobj)


def incr_backup(src_dir, dst_dir, md5file):
    fname = os.path.basename(src_dir.rstrip('/'))
    fname = '%s_incr_%s.tar.gz' % (fname, time.strftime('%Y%m%d'))
    fname = os.path.join(dst_dir, fname)
    md5dict = {}

    with open(md5file, 'rb') as fobj:
        oldmd5 = pickle.load(fobj)

    for path, folders, files in os.walk(src_dir):
        for each_file in files:
            key = os.path.join(path, each_file)
            md5dict[key] = check_md5(key)

    with open(md5file, 'wb') as fobj:
        pickle.dump(md5dict, fobj)

    tar = tarfile.open(fname, 'w:gz')
    for key in md5dict:
        if oldmd5.get(key) != md5dict[key]:
            tar.add(key)
    tar.close()

if __name__ == '__main__':
    # mkdir /tmp/demo; cp -r /etc/security /tmp/demo
    src_dir = '/tmp/demo/security'
    dst_dir = '/var/tmp/backup'   # mkdir /var/tmp/backup
    md5file = '/var/tmp/backup/md5.data'
    if time.strftime('%a') == 'Mon':
        full_backup(src_dir, dst_dir, md5file)
    else:
        incr_backup(src_dir, dst_dir, md5file)




os.walk(top, topdown=True, onerror=None, followlinks=False)
遍历目录树，自顶向下或自底向上生成目录树下的文件名。对根目录top（包括根目录top本身）中的每个目录，它都会yield一个3元元组(dirpath, dirnames, filenames)。

dirpath是一个字符串，为目录路径。dirnames是dirpath中子目录的名称列表（不包括'.'和'..')。文件名是dirpath中非目录文件的名称列表。注意，列表中的名称不包含路径部分。要获得dirpath 中的文件或目录的完整路径(以 top开头), 请使用os.path.join(dirpath, name).

如果可选参数topdown为True或未指定，则在生成其任何子目录的三元组tuple之前生成其本身的三元组tuple。（简言之就是自上而下遍历）如果topdown是False，则在生成所有子目录的三元组之后生成其本身的三元组（即自下而上生成）。无论topdown的值如何，在生成目录及其子目录的元组之前，都会检索子目录列表。

当topdown为True时，调用者可以就地修改dirnames列表（也许使用del ），并且walk()仅会递归到名称保留在dirnames中的子目录；这可以用来修剪搜索，强制访问的特定顺序，甚至可以通知walk()关于调用者在恢复之前创建或重命名的目录walk()再次。当topdown为False时，修改dirnames对walk的行为没有影响，因为在自底向上模式下，dirnames 在dirpath本身生成之前生成。

默认情况下，来自listdir()的错误将被忽略。如果指定了可选参数onerror，它应该是一个函数；it will be called with one argument, an OSError instance.它可以报告错误以继续步行，或者提出异常以中止步行。请注意，文件名可用作异常对象的filename属性。

默认情况下，walk()不会走向解析为目录的符号链接。在支持它们的系统上，设置followlinks为True以访问由符号链接指向的目录。

注意请注意，如果链接指向其自身的父目录，则将followlinks设置为True可导致无限递归。walk()不会跟踪它已经访问的目录。
注意如果传递相对路径名，请不要在walk()重新开始之间更改当前工作目录。walk()永远不会更改当前目录，并假定它的调用者也不会。
此示例显示非目录文件在起始目录下的每个目录中占用的字节数，但不显示在任何CVS子目录下：

import os
from os.path import join, getsize
for root, dirs, files in os.walk('python/Lib/email'):
    print(root, "consumes", end=" ")
    print(sum(getsize(join(root, name)) for name in files), end=" ")
    print("bytes in", len(files), "non-directory files")
    if 'CVS' in dirs:
        dirs.remove('CVS')  # don't visit CVS directories
In the next example (simple implementation of shutil.rmtree()), walking the tree bottom-up is essential, rmdir() doesn’t allow deleting a directory before the directory is empty:

# Delete everything reachable from the directory named in "top",
# assuming there are no symbolic links.
# CAUTION:  This is dangerous!  For example, if top == '/', it
# could delete all your disk files.
import os
for root, dirs, files in os.walk(top, topdown=False):
    for name in files:
        os.remove(os.path.join(root, name))
    for name in dirs:
        os.rmdir(os.path.join(root, name))
Changed in version 3.5: This function now calls os.scandir() instead of os.listdir(), making it faster by reducing the number of calls to os.stat().












