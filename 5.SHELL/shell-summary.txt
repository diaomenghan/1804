Top
NSD SHELL DAY01

案例1：Shell基础应用
案例2：简单Shell脚本的设计
案例3：使用Shell变量
案例4：变量的扩展应用

命令运行过程
外围应用程序<--->用户
命令解释器-->系统内核-->计算机硬件




1 案例1：Shell基础应用
1.1 问题

本案例要求熟悉Linux Shell环境的特点，主要练习以下操作：
切换用户的Shell环境
练习命令历史、命令别名
重定向标准输入/输出/错误输出
管道操作实践
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：切换用户的Shell环境

若需要临时使用另一种Shell环境，可以直接执行对应的Shell解释器程序，比如只要执行ksh可以切换到ksh命令行环境。
[root@svr5 ~]# yum -y install ksh              //若缺少ksh请先安装ksh包
.. ..
[root@svr5 ~]# cat /etc/shells
/bin/sh
/bin/bash
/sbin/nologin
/bin/tcsh
/bin/csh
/bin/ksh                                        //确认当前系统已识别ksh
[root@svr5 ~]# ksh                              //进入ksh环境
[root@svr5]~# exit                              //返回到切换前的bash环境
若希望修改用户的登录Shell，管理员可以直接通过usermod命令设置。比如，以下操作可将用户zhangsan的登录Shell改为/bin/ksh：
[root@svr5 ~]# usermod -s /bin/ksh zhangsan              //执行修改操作
[root@svr5 ~]# grep 'zhangsan' /etc/passwd
zhangsan:x:516:516::/home/zhangsan:/bin/ksh              //修改后
步骤二：练习命令历史

1）检查历史命令的容量。
默认记录1000条，通过全局变量HISTSIZE设置，对所有用户有效：
[root@svr5 ~]# grep HISTSIZE /etc/profile
HISTSIZE=1000

命令HISTSIZE=50 可临时修改history的记录数

查看已为当前用户记录的历史命令条数：
[root@svr5 ~]# history | wc -l
1000
2）查看历史命令列表。
列出最近执行的10条历史命令：
[root@svr5 ~]# history | tail
 1028  grep 'zhangsan' /etc/passwd
 1029  cat /etc/redhat-release
 1030  usermod -s /bin/tcsh zhangsan
 1031  grep 'zhangsan' /etc/passwd
 1032  su - zhangsan
 1033  echo 1234567 | passwd --stdin zhangsan
 1034  su - zhangsan
 1035  grep HISTSIZE /etc/profile
 1036  history | wc -l
 1037  history | tail
3）调用指定的历史命令。
重新执行历史命令列表中的第1028条操作：
[root@svr5 ~]# !1028
grep 'zhangsan' /etc/passwd
zhangsan:x:516:516::/home/zhangsan:/bin/bash
重新执行最近一次以cat开头（根据实际情况变更）的历史命令操作：
[root@svr5 ~]# !cat
cat /etc/redhat-release
Red Hat Enterprise Linux Server release 5.9 (Tikanga)
4）清空已记录的历史命令。
[root@svr5 ~]# history -c                      //清空自己的历史命令
[root@svr5 ~]# > ~/.bash_history                  //清空记录文件
[root@svr5 ~]# history                          //再次检查历史命令列表
   42  > ~/.bash_history
   43  history
步骤三：练习命令别名

1）查看已经定义的命令别名列表。
当前的别名列表：
[root@svr5 ~]# alias
alias cp='cp -i'
alias l.='ls -d .* --color=tty'
alias ll='ls -l --color=tty'
alias ls='ls --color=tty'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
别名设置一般存放在用户的.bashrc文件内：
[root@svr5 ~]# grep '^alias' ~/.bashrc
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
2）自定义新的命令别名
添加一个名为lh的命令别名，实际执行的是“ls –lh –color=tty”：
[root@svr5 ~]# alias lh='ls -lh'                      //定义别名命令lh
[root@svr5 ~]# alias lh                              //确认定义结果
alias lh='ls -lh'
验证别名命令的效果：
[root@svr5 ~]# lh /etc/fstab                          //使用别名
-rw-r--r-- 1 root root 733 10-09 15:34 /etc/fstab
[root@svr5 ~]# ls -lh /etc/fstab                      //使用完整的命令
-rw-r--r-- 1 root root 733 10-09 15:34 /etc/fstab
3）取消别名
取消单个别名：
[root@svr5 ~]# unalias lh                          //取消名为lh的命令别名
[root@svr5 ~]# alias lh                              //查询时已没有lh
-bash: alias: lh: not found
步骤四：重定向标准输入/输出/错误输出

标准输入（stdin），描述号为0；标准输出（stdout），描述号为1；标准错误（stderr），描述号为2。
1）重定向标准输出。
使用 > 将命令执行的正常输出重定向到文件：
[root@svr5 ~]# ls -ld /etc/                        //正常应输出到屏幕
drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
[root@svr5 ~]# ls -ld /etc/ > stdout.txt              //重定向到文件
[root@svr5 ~]# cat stdout.txt                      //确认重定向输出的结果
drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
> 操作会覆盖目标文件（先清空、再写入）：
[root@svr5 ~]# echo "I am the king." > stdout.txt          //覆盖目标文件
[root@svr5 ~]# cat stdout.txt                          //确认结果
I am the king.
改用 >> 可实现追加重定向输出：
[root@svr5 ~]# ls -ld /etc/  >> stdout.txt              //追加输出
[root@svr5 ~]# cat stdout.txt
I am the king.                                          //原有内容还保留
drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
2）重定向标准错误。
对于命令执行出错的信息，使用 > 无法保存，仍然会输出到屏幕。比如，可使用ls命令同时查看两个对象（其中nofile并不存在），重定向输出：
[root@svr5 ~]# ls -l nofile.txt /etc/fstab > stderr.txt
 [root@svr5 ~]# cat stderr.txt                  //正常信息成功重定向到目标文件
-rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
使用 2> 可重定向错误信息，比如，可执行一个错误的命令：
[root@svr5 ~]# ls -l nofile.txt /etc/fstab 2> stderr.txt 
-rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
//正确的信息默认输出至屏幕，错误信息重定向到目标文件 
[root@svr5 ~]# cat stderr.txt                        //从文件中查看出错信息
ls: nofile.txt: 没有那个文件或目录
类似的，2>> 可实现追加输出：
[root@svr5 ~]# ls tmpfile 2>> stderr.txt
[root@svr5 ~]# cat stderr.txt
ls: nofile.txt: 没有那个文件或目录
ls: tmpfile: 没有那个文件或目录
若希望将正常输出、错误输出重定向同一个文件，可使用 &> :
[root@svr5 ~]# ls -l nofile.txt /etc/fstab &> stderr.txt
[root@svr5 ~]# cat stderr.txt
ls: nofile.txt: 没有那个文件或目录
-rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
3）重定向标准输入。
[root@svr5 ~]# mail –s Error  root   < /etc/passwd
4）案例
[root@svr5 ~]# cat  /root/test.sh
#!/bin/bash
for  i   in   {1..10}
do
            useradd  user$i  2>>/root/user.log
            echo  '123456' | passwd  --stdin  user$i  >/dev/null
done
步骤五：管道操作实践

借助于管道符“|”，可以将一条命令的标准输出交给另一条命令处理，在一条命令行内可依次使用多个管道。
1）统计/etc/目录下资料的数量。
[root@svr5 ~]# ls -l /etc | wc -l
254
2）列出Yum库里名称中含cluster的软件包。
[root@svr5 ~]# yum list | grep cluster
cluster-cim.x86_64                 0.12.1-7.el5     RHEL5-Cluster
cluster-snmp.x86_64                 0.12.1-7.el5     RHEL5-Cluster
… …
2 案例2：简单Shell脚本的设计
2.1 问题

本案例要求编写三个脚本程序，分别实现以下目标：
在屏幕上输出一段文字“Hello World”
能够为本机快速配好Yum仓库
能够为本机快速装配好vsftpd服务
2.2 方案

一个规范的Shell脚本构成包括：
脚本声明（需要的解释器、作者信息等）
注释信息（步骤、思路、用途、变量含义等）
可执行语句（操作代码）
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写第一个Shell脚本，输出“Hello World”

1）根据手动任务操作编写脚本文件
[root@svr5 ~]# vim  /root/first.sh  
#!/bin/bash
echo  'Hello World' 
[root@svr5 ~]# chmod  +x  /root/first.sh                      //添加可执行权限
2）执行脚本，测试效果
[root@svr5 ~]# /root/first.sh 
Hello World
3）Shell脚本的执行方式：
方法一，作为“命令字”：指定脚本文件的路径，前提是有 x 权限
[root@svr5 ~]# ./first.sh                            //指定相对路径
[root@svr5 ~]# /root/first.sh                        //指定绝对路径
方法二，作为“参数”：使用bash、sh、source来加载脚本文件
[root@svr5 ~]# bash   first.sh                        //开启子进程
[root@svr5 ~]# sh        first.sh                        //开启子进程
[root@svr5 ~]# source first.sh                        //不开启子进程
步骤二：编写为本机快速配Yum仓库的Shell脚本

1）Yum仓库配置文件的参考内容如下：
[root@svr5 ~]# cat /etc/yum.repos.d/rhel.repo 
[rhel]
name=redhat
baseurl=file:///misc/cd
enabled=1
gpgcheck=0
2）根据参考文件的内容，编写脚本内容如下：
[root@svr5 ~]# vim  /root/yum.sh
#!/bin/bash
rm  -rf  /etc/yum.repos.d/*.repo 
echo  '[rhel]
name=redhat
baseurl=file:///misc/cd
gpgcheck=0
'  > /etc/yum.repos.d/rhel.repo 
[root@svr5 ~]# chmod +x /root/yum.sh                      //添加可执行权限
3）执行脚本，测试效果
执行配置Yum仓库的脚本：
[root@svr5 ~]# /root/yum.sh 
检查配置结果：
[root@svr5 ~]# ls /etc/yum.repos.d/*                          //仓库配置已建立
/etc/yum.repos.d/rhel.repo
[root@svr5 ~]# yum repolist                                  //Yum仓库已可用
rhel-packages                              | 3.9 kB     00:00 ... 
rhel-packages/primary_db                  | 3.1 MB     00:00 ... 
repo id                repo name                       status
rhel                     redhat                         3,690
repolist: 3,690
步骤三：编写快速装配vsftpd服务的Shell脚本

1）编写参考脚本文件如下：
[root@svr5 ~]# vim  /root/ftpon.sh
#!/bin/bash
yum  -y  install  vsftpd  &> /dev/null
systemctl  start  vsftpd
systemctl  enable  vsftpd
[root@svr5 ~]# chmod  +x  /root/ftpon.sh                  //添加可执行权限
3）执行脚本，测试效果
执行快速装配vsftpd服务的脚本：
[root@svr5 ~]# /root/ftpon.sh 
确认脚本执行结果：
[root@svr5 ~]# rpm -q vsftpd
vsftpd-3.0.2-10.el7.x86_64
[root@svr5 ~]# systemctl  status  vsftpd
3 案例3：使用Shell变量
3.1 问题

本案例要求熟悉Shell变量的使用，主要练习或验证下列内容：
定义/赋值/查看变量
环境/预定义/位置变量的应用
除了学会建立和引用变量以外，还要认识环境变量PWD、USER、HOME、SHELL，还有预定义变量$0、$$、$?、$#、$*，以及位置变量$1、$2、$10、……的作用。
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：变量的定义/赋值/查看

1）新建/赋值变量
新建变量test，赋值“hello world”，通过set命令可以检查变量设置：
[root@svr5 ~]# test=11
2）查看变量
通过echo $变量名 可输出变量值：
[root@svr5 ~]# echo $test
11
查看变量时，若变量名称与后面要输出的字符串连在一起，则应该以{}将变量名括起来以便区分：
[root@svr5 ~]# echo $testRMB              //无法识别变量名test
[root@svr5 ~]# echo ${test}RMB              //区分后可以识别
11RMB
3）撤销自定义变量
若要撤销已有的变量，可使用unset命令：
[root@svr5 ~]# unset test                  //撤销变量test
[root@svr5 ~]# echo $test                  //查看时已无结果
步骤二：使用环境变量

1）查看环境变量相关文件
全局文件为/etc/profile，对所有用户有效；用户文件为~/.bash_profile，仅对指定的用户有效。
查看/etc/profile文件内容：
[root@svr5 ~]# cat /etc/profile
.. ..
HOSTNAME=`/bin/hostname`
HISTSIZE=1000
.. ..
export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC
.. ..
2）使用环境变量
当前用户的环境变量USER记录了用户名、LOGNAME记录了登录名、HOME记录了宿主目录、SHELL记录了登录Shell、HOSTNAME记录主机名、TERM记录终端类型：
[root@svr5 ~]# echo $USER $HOME $SHELL
root /root /bin/bash
[root@svr5 ~]# echo $HOSTNAME
svr5
环境变量PS1表示Shell环境的一级提示符，即命令行提示符（\u 用户名、\h 主机名、\W 工作目录、\$ 权限标识）：
[root@svr5 src]# echo $PS1                  //查看默认的一级提示
[\u@\h \W]\$
[root@svr5 src]#PS1='hehe#'                  //修改一级提示
hehe#                                      //更改结果
hehe# PS1='[\u@\h \W]\$ '                  //恢复原有设置
[root@svr5 src]# 
环境变量PS2表示二级提示符，出现在强制换行、at任务编辑等场合：
[root@svr5 ~]# echo $PS2                      //查看默认的二级提示
>
[root@svr5 src]# cd \                     //强制换行，观察提示符效果
> /root/
[root@svr5 ~]# PS2='=> '                      //手动修改二级提示
[root@svr5 ~]# cd \                          //再次验证提示符效果
=> ~
[root@svr5 ~]# PS2='> '                     //恢复原有设置
3）查看系统变量
使用env可查看所有环境变量：
[root@svr5 src]# env
HOSTNAME=svr5.tarena.com
SHELL=/bin/bash
HISTSIZE=1000
SSH_CLIENT=192.168.4.110 59026 22
OLDPWD=/root
SSH_TTY=/dev/pts/0
USER=root
.. ..
使用set可查看所有变量（包括env能看到的环境变量）：
[root@svr5 src]# set
BASH=/bin/bash
BASH_ARGC=()
BASH_ARGV=()
BASH_LINENO=()
.. ..
步骤三：使用位置变量与预定义变量

1）创建一个测试脚本，用来展示。
[root@svr5 ~]# vim location.sh
#!/bin/bash
echo $0                                        //脚本的名称
echo $1                                        //第一个参数
echo $2                                        //第二个参数
echo $*                                        //所有参数
echo $#                                        //所有参数个数
echo $$                                        //当前进程的进程号
echo $?                                        //上一个程序的返回状态码
[root@svr5 ~]# chmod +x location.sh              //添加可执行权限
2）执行脚本location.sh，细心观察结果（高明的武功需要用心参悟）。
[root@svr5 ~]# ./location.sh one 1 2 abc qq 8 7
步骤四：创建账户与修改密码的脚本

1）编写脚本。
[root@svr5 ~]# vim /root/user.sh
#!/bin/bash
useradd $1
echo "$2" |passwd --stdin $1 
执行脚本测试：
[root@svr5 ~]# ./user.sh jerry  123456
更改用户 jerry 的密码 。
passwd： 所有的身份验证令牌已经成功更新。
4 案例4：变量的扩展应用
4.1 问题

本案例要求进一步熟悉Shell变量的赋值控制，主要练习或验证下列内容：
三种引号对赋值的影响
使用read命令从键盘读取变量值
使用export发布全局变量
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：三种引号对变量赋值的影响

1）双引号的应用
使用双引号可以界定一个完整字符串。
[root@svr5 ~]# SCHOOL=Tarena IT Group
-bash: IT: command not found                      //未界定时赋值失败
[root@svr5 ~]# SCHOOL="Tarena IT Group"          //界定后成功
[root@svr5 ~]# touch aa bb                      //创建了两个文件
[root@svr5 ~]# touch "aa bb"                    //创建了一个文件
[root@svr5 ~]# ls                                //查看结果
2）单引号的应用
界定一个完整的字符串，并且可以实现屏蔽特殊符号的功能。
[root@svr5 ~]# echo "$test"
[root@svr5 ~]# echo '$test'
3）反撇号或$()的应用
使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换。
[root@svr5 ~]# tar -czf log-`date +%Y%m%d`.tar.gz /var/log
步骤二：使用read命令从键盘读取变量值

1）read基本用法
执行后从会等待并接受用户输入（无任何提示的情况），并赋值给变量str：
[root@svr5 ~]# read str
What's happen ?                          //随便输入一些文字，按Enter键提交
[root@svr5 ~]# echo $str                  //查看赋值结果
What's happen ?
为了不至于使用户不知所措、莫名其妙，推荐的做法是结合-p选项给出友好提示：
[root@svr5 ~]# read -p "请输入一个整数：" i
请输入一个整数：240
[root@svr5 ~]# echo $i
240
2）stty终端显示控制
将回显功能关闭（stty -echo），
将回显功能恢复（stty echo）。
可参考下列操作创建一个测试脚本：
[root@svr5 ~]# vim sttyecho.sh              //创建一个测试脚本
#!/bin/bash
read -p "请输入用户名: " USERNAME              //读取用户名
stty -echo                                  //关闭回显
read -p "请输入密码: " PASSWORD              //读取密码
stty echo                                  //恢复回显
echo ""                                      //恢复回显后补一个空行
echo "您的用户名是: $USERNAME"              //确认赋值结果
[root@svr5 ~]# chmod +x sttyecho.sh          //添加执行权限
执行测试脚本sttyecho.sh，验证效果：
[root@svr5 ~]# ./sttyecho.sh
请输入用户名:  root                          //输入root，回车
请输入密码:                                   //输入1234567（不会显示），回车
您的用户名是: root                          //脚本反馈结果
步骤三：使用export发布全局变量

默认情况下，自定义的变量为局部变量，只在当前Shell环境中有效，而在子Shell环境中无法直接使用。比如已定义的SCHOOL变量，当进入到sh或bash子Shell后，变量SCHOOL将处于未定义的状态：
[root@svr5 ~]# SCHOOL="Tarena IT Group"
[root@svr5 ~]# echo $SCHOOL
Tarena IT Group
[root@svr5 ~]# bash                              //开启bash子进程
[root@svr5 ~]# echo $SCHOOL                      //查看SCHOOL变量值无结果
[root@svr5 ~]# exit                              //返回原有Shell环境
exit
[root@svr5 ~]# echo $SCHOOL
若希望定义的变量能被子进程使用，可以使用export命令将其发布为全局变量。使用export发布时，只需指定变量名（可以有多个）即可，也可以通过export命令直接设置新的全局变量：
[root@svr5 ~]# export SCHOOL                          //发布已定义的变量
[root@svr5 ~]# export XX="1234"                      //发布新变量
验证刚刚发布的全局变量：
[root@svr5 ~]# bash                                  //进入bash子Shell环境
[root@svr5 ~]# echo $SCHOOL                          //查看全局变量的值 .. ..
Tarena IT Group
[root@svr5 ~]# echo $XX
1234





Top
NSD SHELL DAY02

案例1：Shell中的数值运算
案例2：条件测试操作
案例3：使用if选择结构
1 案例1：Shell中的数值运算
1.1 问题

本案例要求熟悉Linux Shell环境的特点，主要练习以下操作：
使用expr、$[ ]、let等整数运算工具：定义变量X=1234，然后计算X与78的四则运算及求模结果
使用bc实现小数运算操作：以交互方式计算12.34与56.78的四则运算结果，另外再以非交互方式重复上述计算，最多显示4位小数
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：整数运算工具

1）使用expr命令
乘法操作应采用 \* 转义，避免被作为Shell通配符；参与运算的整数值与运算操作符之间需要以空格分开，引用变量时必须加$符号。
首先定义变量X=1234，然后分别计算与78的加减乘除和求模运算结果：
[root@svr5 ~]# X=1234                              //定义变量X
[root@svr5 ~]# expr  $X  +  78                      //加法
1312
[root@svr5 ~]# expr  $X  -  78                       //减法
1156
[root@svr5 ~]# expr  $X  \*  78                      //乘法，操作符应添加\转义
96252
[root@svr5 ~]# expr  $X  /  78                      //除法，仅保留整除结果
15
[root@svr5 ~]# expr  $X  %  78                     //求模
64

2**10 表示2的10次幂

2）使用$[]或$(())表达式
乘法操作*无需转义，运算符两侧可以无空格；引用变量可省略 $ 符号；计算结果替换表达式本身，可结合echo命令输出。
同样对于变量X=1234，分别计算与78的加减乘除和求模运算结果：
[root@svr5 ~]# X=1234   
[root@svr5 ~]# echo $[X+78]
1312
[root@svr5 ~]# echo $[X-78]
1156
[root@svr5 ~]# echo $[X*78]
96252
[root@svr5 ~]# echo $[X/78]
15
[root@svr5 ~]# echo $[X%78]
64
3）使用let命令
expr或$[]、$(())方式只进行运算，并不会改变变量的值；而let命令可以直接对变量值做运算再保存新的值。因此变量X=1234，在执行let运算后的值会变更；另外，let运算操作并不显示结果，但是可以结合echo命令来查看：
[root@svr5 ~]# X=1234  
[root@svr5 ~]# let y=X+22
[root@svr5 ~]# echo $y
1256
[root@svr5 ~]# let X++;  echo $X                    # X++(X=X+1)
[root@svr5 ~]# let X--;  echo $X                    # X--(X=X-1)
[root@svr5 ~]# let X+=78 ; echo $X                    # X+=78(X=X+78)
[root@svr5 ~]# let X-=78 ; echo $X                 # X-=78(X=X-78)
[root@svr5 ~]# let X*=78 ; echo $X                 # X*=78(X=X*78)
[root@svr5 ~]# let X/=78 ; echo $X                 # X/=78(X=X/78)
[root@svr5 ~]# let X%=78 ; echo $X                 # X%=78(X=X%79)
步骤二：小数运算工具

1）bc交互式运算
先执行bc命令进入交互环境，然后再输入需要计算的表达式。以计算小数12.34与5.678的四则运算为例，相关操作如下：
[root@svr5 ~]# bc 
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
12.34+56.78                                        //加法
69.12
12.34-56.78                                        //减法
-44.44
12.34*56.78                                        //乘法
700.66
12.34/56.78                                        //除法
0
quit                                              //退出交互计算器
[root@svr5 ~]#
2）bc非交互式运算
将需要运算的表达式通过管道操作交给bc运算。注意，小数位的长度可采用scale=N限制，除此以外也受参与运算的数值的小数位影响。以计算小数12.34与5.678的四则运算为例，相关操作如下：
[root@svr5 ~]# echo 'scale=4;12.34+5.678' | bc
18.018
[root@svr5 ~]# echo 'scale=4;12.34-5.678' | bc 
6.662
[root@svr5 ~]# echo 'scale=4;12.34*5.678' | bc 
70.0665
[root@svr5 ~]# echo 'scale=4;12.34/5.678' | bc 
2.1733
2 案例2：条件测试操作
2.1 问题

本案例要求参考PPT上的示例，分别练习以下条件测试操作：
字符串匹配
比较整数值的大小
识别文件/目录的状态
多个条件/操作的逻辑组合
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：条件测试的基本用法

1）语法格式
使用“test 表达式”或者[ 表达式 ]都可以，表达式两边至少要留一个空格。
条件测试操作本身不显示出任何信息。测试的条件是否成立主要体现在命令执行后的返回状态（即 $?），所以可以在测试后查看变量$?的值来做出判断，或者结合&&、||等逻辑操作显示出结果（或作其他操作） 。
步骤二：字符串测试

1）== 比较两个字符串是否相同
检查当前用户是否为root。
当root用户执行时：
[root@svr5 ~]# [ $USER == "root" ]             //测试
[root@svr5 ~]# echo $?                        //查看结果0为对，非0为错
当普通用户执行时：
[zengye@svr5 ~]$ [ $USER == "root" ]
[zengye@svr5 ~]$ echo $?
2）!= 比较两个字符串是否不相同
检查当前用户，如果不是root。
当普通用户执行时：
[zengye@svr5 ~]$ [ $USER != "root" ] 
当root用户执行时：
[root@svr5 ~]# [ $USER != "root" ]
3）-z 检查变量的值是否未设置（空值）
[root@svr5 ~]# var1="Tarena" ; var2=""
[root@svr5 ~]# [ -z "$var1" ] && echo "空值" || echo "非空值"
非空值
[root@svr5 ~]# [ -z $var2 ] && echo "空值" || echo "非空值"
空值                                      //变量var2已设置，但无任何值，视为空
[root@svr5 ~]# [ ! -z $var1 ]                //测试var1是否为非空 

!!!	A && B 仅当A成功时，才执行B
!!!	A || B 仅当A失败时，才执行B（2选1）
!!!	A ； B 执行A，执行B



步骤三：整数值比较

参与比较的必须是整数（可以调用变量），比较非整数值时会出错：
[root@svr5 ~]# A=20.4
[root@svr5 ~]# [ $A -gt 10 ]                  //不支持小数比较
-bash: [: 20.4: integer expression expected
1）-eq 比较两个数是否相等。
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -eq 20 ] && echo "相等" || echo "不相等"
相等
[root@svr5 ~]# [ $X -eq 30 ] && echo "相等" || echo "不相等"
不相等
2）-ne 比较两个数是否不相等。
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -ne 20 ] && echo "不等于" || echo "等于"
等于
[root@svr5 ~]# [ $X -ne 30 ] && echo "不等于" || echo "等于"
不等于
3）-gt 比较前面的整数是否大于后面的整数。
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -gt 10 ] && echo "大于" || echo "否"
大于
[root@svr5 ~]# [ $X -gt 20 ] && echo "大于" || echo "否"
否
[root@svr5 ~]# [ $X -gt 30 ] && echo "大于" || echo "否"
否
4）-ge 比较前面的整数是否大于或等于后面的整数。
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -ge 10 ] && echo "大于或等于" || echo "否"
大于或等于
[root@svr5 ~]# [ $X -ge 20 ] && echo "大于或等于" || echo "否"
大于或等于
[root@svr5 ~]# [ $X -ge 30 ] && echo "大于或等于" || echo "否"
否
5）-lt 比较前面的整数是否小于后面的整数。
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -lt 10 ] && echo "小于" || echo "否"
否
[root@svr5 ~]# [ $X -lt 20 ] && echo "小于" || echo "否"
否
[root@svr5 ~]# [ $X -lt 30 ] && echo "小于" || echo "否"
小于
6）-le 比较前面的整数是否小于或等于后面的整数。
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -le 10 ] && echo "小于或等于" || echo "否"
否
[root@svr5 ~]# [ $X -le 20 ] && echo "小于或等于" || echo "否"
小于或等于
[root@svr5 ~]# [ $X -le 30 ] && echo "小于或等于" || echo "否"
小于或等于
7）提取当前登录的用户数，比较是否超过5。
[root@svr5 ~]# who | wc -l                                  //确认已登录的用户数
4
[root@svr5 ~]# N=$(who | wc -l)                              //赋值给变量N
[root@svr5 ~]# [ $N -gt 5 ] && echo "超过了" || echo "没超过"
没超过
上述赋值给变量N及与5比较的操作，可以简化为如下形式：
[root@svr5 ~]# [ $(who | wc -l) -gt 5 ] && echo "超过了" || echo "没超过"
没超过
步骤四：识别文件/目录的状态

1）-e 判断对象是否存在（不管是目录还是文件）
[root@svr5 ~]# [ -e "/usr/" ] && echo "存在" || echo "不存在"
存在
[root@svr5 ~]# [ -e "/etc/fstab" ] && echo "存在" || echo "不存在"
存在
[root@svr5 ~]# [ -e "/home/nooby" ] && echo "存在" || echo "不存在"
不存在
2）-d 判断对象是否为目录（存在且是目录）
[root@svr5 ~]# [ -d "/usr/" ] && echo "是目录" || echo "不是目录"
是目录
[root@svr5 ~]# [ -d "/etc/fstab" ] && echo "是目录" || echo "不是目录"
不是目录
[root@svr5 ~]# [ -d "/home/nooby" ] && echo "是目录" || echo "不是目录"
不是目录
3）-f 判断对象是否为文件（存在且是文件）
[root@svr5 ~]# [ -f "/usr/" ] && echo "是文件" || echo "不是文件"
不是文件
[root@svr5 ~]# [ -f "/etc/fstab" ] && echo "是文件" || echo "不是文件"
是文件
[root@svr5 ~]# [ -f "/home/nooby" ] && echo "是文件" || echo "不是文件"
不是文件
4）-r 判断对象是否可读
此测试对root用户无效，无论文件是否设置r权限，root都可读：
[root@svr5 ~]# cp /etc/hosts /tmp/test.txt          //复制一个文件做测试
[root@svr5 ~]# chmod -r /tmp/test.txt              //去掉所有的r权限
[root@svr5 ~]# [ -r "/tmp/test.txt" ] && echo "可读" || echo "不可读"
可读                                              //root测试结果仍然可读
切换为普通用户，再执行相同的测试，结果变为“不可读”：
[zengye@svr5 ~]$ [ -r "/tmp/test.txt" ] && echo "可读" || echo "不可读"
不可读
5）-w 判断对象是否可写
此测试同样对root用户无效，无论文件是否设置w权限，root都可写：
[root@svr5 ~]# chmod -w /tmp/test.txt             //去掉所有的w权限
[root@svr5 ~]# ls -l /tmp/test.txt              //确认设置结果
---------- 1 root root 33139 12-11 10:43 /tmp/test.txt

[root@svr5 ~]# [ -w "/tmp/test.txt" ] && echo "可写" || echo "不可写"
可写
切换为普通用户，可以正常使用-w测试：
[zengye@svr5 ~]$ ls -l /tmp/test.txt
---------- 1 root root 33139 12-11 10:52 /tmp/test.txt
[zengye@svr5 ~]$ [ -w "/tmp/test.txt" ] && echo "可写" || echo "不可写"
不可写
6）-x 判断对象是否具有可执行权限
这个取决于文件本身、文件系统级的控制，root或普通用户都适用：
[root@svr5 ~]# chmod 644 /tmp/test.txt          //重设权限，无x
[root@svr5 ~]# ls -l /tmp/test.txt              //确认设置结果
-rw-r--r-- 1 root root 33139 12-11 10:52 /tmp/test.txt
[root@svr5 ~]# [ -x "/tmp/test.txt" ] && echo "可执行" || echo "不可执行"
不可执行
[root@svr5 ~]# chmod +x /tmp/test.txt          //添加x权限
[root@svr5 ~]# [ -x "/tmp/test.txt" ] && echo "可执行" || echo "不可执行"
可执行
步骤五：多个条件/操作的逻辑组合

1）&&，逻辑与
给定条件必须都成立，整个测试结果才为真。
检查变量X的值是否大于10，且小于30：
[root@svr5 ~]# X=20                      //设置X变量的值为20
[root@svr5 ~]# [ $X -gt 10 ] && [ $X -lt 30 ] && echo "YES"
YES
多个条件组合时，可以使用 [[ .. ]] 界定，比如上述测试可以改为如下：
[root@svr5 ~]# [[ $X -gt 10 && $X -lt 30 ]] && echo "YES"
YES
2）||，逻辑或
只要其中一个条件成立，则整个测试结果为真。
检查变量X的值是否小于10或者小于30：
[root@svr5 ~]# [[ $X -lt 10 || $X -lt 30 ]] && echo "YES"
YES
只要/tmp/、/var/spool/目录中有一个可写，则条件成立：
[root@svr5 ~]# [ -w "/tmp/" ] || [ -w "/var/spool/" ] && echo "OK"
OK
3 案例3：使用if选择结构
3.1 问题

本案例要求编写3个Shell脚本，分别实现以下目标：
检测/media/cdrom目录，若不存在则创建
检测并判断指定的主机是否可ping通
从键盘读取一个论坛积分，判断论坛用户等级，等级分类如下:
大于等于90	神功绝世
大于等于80，小于90	登峰造极
大于等于70，小于80	炉火纯青
大于等于60，小于70	略有小成
小于60	初学乍练
3.2 方案

if单分支的语法组成：
if  条件测试
    then  命令序列
fi
if双分支的语法组成：
if  条件测试
    then  命令序列1
    else  命令序列2
fi
if多分支的语法组成：
if  条件测试1
    then  命令序列1
elif  条件测试2
    then  命令序列2
    else  命令序列n
fi
if多分支结构实际上相当于多层if嵌套：
if  条件测试1  ; then
    命令序列1
else
    if  条件测试2  ; then
        命令序列2
    else
        .. ..
        命令序列n
    fi
fi
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：检测/media/cdrom目录，若不存在则创建

1）编写脚本如下：
[root@svr5 ~]# vim mountdir.sh 
#!/bin/bash
dir="/media/cdrom/"
if [ ! -d $dir ]
then
    mkdir -p $dir
fi 
[root@svr5 ~]# chmod +x mountdir.sh                  //添加可执行权限
2）测试、验证脚本功能
[root@svr5 ~]# ls -ld /media/cdrom                  //本来没有/media/cdrom目录
ls: /media/cdrom: 没有那个文件或目录
[root@svr5 ~]# ./mountdir.sh                          //执行脚本
[root@svr5 ~]# ls -ld /media/cdrom                  //再检查已经有了
drwxr-xr-x 2 root root 4096 12-11 15:16 /media/cdrom
有了/media/cdrom文件夹以后，再次执行上述脚本，实际上不做任何有效操作：
[root@svr5 ~]# ./mountdir.sh
[root@svr5 ~]#
步骤二：检测并判断指定的主机是否可ping通

1）分析任务需求
使用ping命令检测目标主机时，人工可直接判断反馈结果，而脚本却不方便。但是当ping测试成功时，执行状态$?的值为0；而ping测试失败时，$?的值不为0。因此在Shell脚本中可以利用这一点来判断ping目标主机的成败。
为了节省ping测试时间，可以只发送3个测试包（-c 3）、缩短发送测试包的间隔秒数（-i 0.2）、等待反馈的超时秒数（-W 3）。比如，检查可ping通的主机：
[root@svr5 ~]# ping -c 3 -i 0.2 -W 3 192.168.4.5
PING 192.168.4.5 (192.168.4.5) 56(84) bytes of data.
64 bytes from 192.168.4.5: icmp_seq=1 ttl=64 time=0.131 ms
64 bytes from 192.168.4.5: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.4.5: icmp_seq=3 ttl=64 time=0.073 ms
--- 192.168.4.5 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 402ms
rtt min/avg/max/mdev = 0.073/0.093/0.131/0.027 ms
[root@svr5 ~]# echo $?                                  //执行状态表示成功
0
2）脚本编写参考如下：
[root@svr5 ~]# vim pinghost.sh 
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ] ; then
    echo "Host $1 is up."
else
    echo "Host $1 is down."
fi
[root@svr5 ~]# chmod +x pinghost.sh 
3）测试、验证脚本功能
[root@svr5 ~]# ./pinghost.sh 192.168.4.5
Host 192.168.4.5 is up.
[root@svr5 ~]# ./pinghost.sh 192.168.4.50
Host 192.168.4.50 is down.
步骤三：从键盘读取一个论坛积分，判断论坛用户等级

1）脚本编写参考如下：
大于等于90	神功绝世
大于等于80，小于90	登峰造极
大于等于70，小于80	炉火纯青
大于等于60，小于70	略有小成
大于60	初学乍练
[root@svr5 ~]# vim gradediv.sh 
#!/bin/bash
read -p "请输入积分（0-100）：" JF
if [ $JF –ge 90 ] ; then
    echo "$JF 分，神功绝世"
elif [ $JF –ge 80 ] ; then
    echo "$JF 分，登峰造极"
elif [ $JF –ge 70 ] ; then
    echo "$JF 分，炉火纯青"
elif [ $JF –ge 60 ] ; then
    echo "$JF 分，略有小成"
else
    echo "$JF 分，初学乍练"
fi
[root@svr5 ~]# chmod +x gradediv.sh
3）测试、验证脚本
[root@svr5 ~]# ./gradediv.sh 
请输入积分（0-100）：74
74 分，炉火纯青
[root@svr5 ~]# ./gradediv.sh 
请输入分数（0-100）：68
68 分，略有小成
[root@svr5 ~]# ./gradediv.sh 
请输入分数（0-100）：87
87 分，登峰造极
Top
NSD SHELL DAY03

案例1：使用for循环结构
案例2：使用while循环结构
案例3：基于case分支编写脚本
案例4：使用Shell函数
案例5：中断及退出
1 案例1：使用for循环结构
1.1 问题

本案例要求编写一个Shell脚本chkhosts.sh，利用for循环来检测多个主机的存活状态，相关要求及说明如下：
对192.168.4.0/24网段执行ping检测
ping检测可参考前一天的pinghost.sh脚本
脚本能遍历ping各主机，并反馈存活状态
执行检测脚本以后，反馈结果如图-1所示。
?
图-1
1.2 方案

在Shell脚本应用中，常见的for循环采用遍历式、列表式的执行流程，通过指定变量从值列表中循环赋值，每次复制后执行固定的一组操作。
for循环的语法结构如下所示：
for  变量名  in  值列表
do
    命令序列
done
for  变量名  in  `ls /etc/*.conf`
do
    命令序列
done
for  变量名  in  {1..5}
do
    命令序列
done
for  变量名  in  `seq 5`    ##### 显示12345竖排   seq 5 10 显示56789 10竖排 seq 1 2 10显示13579
do
    命令序列
done
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：练习for循环基本用法

脚本1，通过循环批量显示10个hello world：
[root@svr5 ~]# vim for01.sh
#!/bin/bash
for i in {1..10}
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x for01.sh
[root@svr5 ~]# ./for01.sh
脚本2，通过循环批量显示10个数字：
[root@svr5 ~]# vim for02.sh
#!/bin/bash
for i in {1..10}
do
        echo "$i"
done
[root@svr5 ~]# chmod +x for02.sh
[root@svr5 ~]# ./for01.sh
步骤二：批量检测多个主机的存活状态

1）编写脚本如下：
[root@svr5 ~]# vim chkhosts.sh
#!/bin/bash
for i in {1..254}
do
    ping -c 3 -i 0.2 -W 1 192.168.4.$i &> /dev/null
    if [ $? -eq 0 ] ; then
        echo "Host 192.168.4.$i is up."
    else
        echo "Host 192.168.4.$i is down."
    fi
done                            #-i 每次ping的时间间隔，-W 超时时间
[root@svr5 ~]# chmod +x chkhosts.sh
4）测试、验证脚本
… …
[root@svr5 ~]# ./chkhosts.sh
Host 192.168.4.5 is up.
Host 192.168.4.6 is down
… …

输出99乘法表
#!/bin/bash
for j in `seq 9`
do
        for i in `seq $j`
        do
                echo -n "$j*$i=$[i*j]   "
        done
        echo "" 
done
执行：
1*1=1	
2*1=2	2*2=4	
3*1=3	3*2=6	3*3=9	
4*1=4	4*2=8	4*3=12	4*4=16	
5*1=5	5*2=10	5*3=15	5*4=20	5*5=25	
6*1=6	6*2=12	6*3=18	6*4=24	6*5=30	6*6=36	
7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49	
8*1=8	8*2=16	8*3=24	8*4=32	8*5=40	8*6=48	8*7=56	8*8=64	
9*1=9	9*2=18	9*3=27	9*4=36	9*5=45	9*6=54	9*7=63	9*8=72	9*9=81	


2 案例2：使用while循环结构
2.1 问题

本案例要求编写2个使用while循环的脚本程序，分别实现以下目标：
提示用户猜测一个随机数，直到才对为止
检测192.168.4.0/24网段，列出不在线的主机地址
2.2 方案

while循环属于条件式的执行流程，会反复判断指定的测试条件，只要条件成立即执行固定的一组操作，直到条件变化为不成立为止。所以while循环的条件一般通过变量来进行控制，在循环体内对变量值做相应改变，以便在适当的时候退出，避免陷入死循环。
while循环的语法结构如下所示：
while  条件测试
do
    命令序列
done
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：练习while循环基本用法

脚本1，无心的死循环脚本：
[root@svr5 ~]# vim while01.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
done
[root@svr5 ~]# chmod +x while01.sh
[root@svr5 ~]# ./while01.sh                //死循环，需要使用Ctrl+C终止脚本
脚本2，有效循环脚本：
[root@svr5 ~]# vim while02.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
        let i++
done
[root@svr5 ~]# chmod +x while02.sh
[root@svr5 ~]# ./while02.sh
脚本3，死循环的一般格式：
[root@svr5 ~]# vim while03.sh
#!/bin/bash
while :
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x while03.sh
[root@svr5 ~]# ./while03.sh                //死循环，需要使用Ctrl+C终止脚本
步骤二：提示用户猜测一个随机数，直到才对为止

使用系统自带变量RANDOM提取随机数（1-100），使用while :制作死循环。
脚本编写参考如下：
[root@svr5 ~]# vim guess.sh
#!/bin/bash
num=$[RANDOM%100+1]
i=0
while :
do
   read -p "随机数1-100,你猜:" guess
   let i++                                    //猜一次，计数器加1，统计猜的次数
   if [ $guess -eq $num ];then
        echo "恭喜，猜对了"
        echo "你猜了$i次"
        exit
   elif [ $guess -gt $num ];then
        echo "猜大了"
   else 
        echo "猜小了"
   fi 
[root@svr5 ~]# chmod +x guess.sh
执行脚本并验证结果：
[root@svr5 ~]# ./guess.sh
步骤三：检测192.168.4.0/24网段，列出不在线的主机地址

1）任务需求及思路分析
要求的是“检测192.168.4.0/24网段，列出不在线的主机地址”。
检测目标是一个网段，其网络部分“192.168.4.”可以作为固定的前缀；而主机部分包括从1~254连续的地址，所以可结合while循环和自增变量进行控制。
2）根据实现思路编写脚本
[root@svr5 ~]# vim chknet.sh
#!/bin/bash
i=1
while [ $i -le 254 ]
do
    IP="192.168.4.$i"
    ping -c 3 -i 0.2 -W 1 $IP &> /dev/null
    if [ $? -eq 0 ] ; then
        echo "Host $IP is up."
    else
        echo "Host $IP is down."
    fi
    let i++
done
[root@svr5 ~]# chmod +x chknet.sh 
3）测试、验证脚本
[root@svr5 ~]# ./chknet.sh
Host 192.168.4.1 is down.
Host 192.168.4.2 is down.
Host 192.168.4.3 is down.
Host 192.168.4.4 is down.
Host 192.168.4.5 is up.
.. ..
Host 192.168.4.250 is down.
Host 192.168.4.251 is down.
Host 192.168.4.252 is down.
Host 192.168.4.253 is down.
Host 192.168.4.254 is down.


3 案例3：基于case分支编写脚本
3.1 问题

本案例要求编写test.sh脚本，相关要求如下：
能使用redhat、fedora控制参数
控制参数通过位置变量$1传入
当用户输入redhat参数，脚本返回fedora
当用户输入fedora参数，脚本返回redhat
当用户输入其他参数，则提示错误信息
3.2 方案

case分支属于匹配执行的方式，它针对指定的变量预先设置一个可能的取值，判断该变量的实际取值是否与预设的某一个值相匹配，如果匹配上了，就执行相应的一组操作，如果没有任何值能够匹配，就执行预先设置的默认操作。
case分支的语法结构如下所示：
case  变量值  in
模式1)
    命令序列1 ;;
模式2)
    命令序列2 ;;
    .. ..
*)
    默认命令序列
esac
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写脚本文件

脚本编写参考如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
case $1 in
redhat)
        echo "fedora";;
fedora)
        echo "redhat";;
    *)                                              //默认输出脚本用法
    echo "用法: $0 {redhat|fedora}"
    exit 1
esac
[root@svr5 ~]# chmod +x test.sh
步骤三：验证、测试脚本

未提供参数，或提供的参数无法识别时，提示正确用法：
[root@svr5 ~]# ./test.sh
用法: ./test.sh {redhat|fedora}
确认可响应redhat控制参数：
[root@svr5 ~]# ./test.sh redhat
fedora
确认可响应fedora控制参数：
[root@svr5 ~]# ./test.sh fedora
redhat
4 案例4：使用Shell函数
4.1 问题

本案例要求编写脚本mycolor.sh，相关要求如下：
将颜色输出的功能定义为函数
调用函数，可以自定义输出内容和颜色
4.2 方案

在Shell脚本中，将一些需重复使用的操作，定义为公共的语句块，即可称为函数。通过使用函数，可以使脚本代码更加简洁，增强易读性，提高Shell脚本的执行效率
1）函数的定义方法
格式1：
function  函数名 {
    命令序列
    .. ..
}
格式2：
函数名() {
    命令序列
    .. ..
}
2）函数的调用
直接使用“函数名”的形式调用，如果该函数能够处理位置参数，则可以使用“函数名 参数1 参数2 .. ..”的形式调用。
注意：函数的定义语句必须出现在调用之前，否则无法执行。
3) 测试语法格式
[root@svr5 ~]# mycd(){                        //定义函数
> mkdir /test
> cd /test
> }
[root@svr5 ~]# mycd                            //调用函数
[root@svr5 ~]# mycd(){                        //定义函数
> mkdir $1
> cd $1
> }
[root@svr5 ~]# mycd  /abc                            //调用函数
[root@svr5 ~]# mycd  /360                            //调用函数
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写mycolor.sh脚本

1）任务需求及思路分析
用户在执行时提供2个整数参数，这个可以通过位置变量$1、$2读入。
调用函数时，将用户提供的两个参数传递给函数处理。
颜色输出的命令:echo -e "\033[32mOK\033[0m"。
0X为样式
3X为字体颜色，4X为背景颜色。
2）根据实现思路编写脚本文件
[root@svr5 ~]# vim mycolor.sh
#!/bin/bash
cecho() {
    echo –e "\033[$1m$2\033[0m"
}
cecho 32 OK
cecho 33 OK
cecho 34 OK
cecho 35 OK
[root@svr5 ~]# chmod +x mycolor.sh
3）测试脚本执行效果
[root@svr5 ~]# ./mycolor.sh

!!! 
#!/bin/bash
.(){
 .|. &
}
.

运行上述程序，无限调用本身函数
电脑司机

5 案例5：中断及退出
5.1 问题

本案例要求编写两个Shell脚本，相关要求如下：
从键盘循环取整数（0结束）并求和，输出最终结果
跳过1~20以内非6的倍数，输出其他数的平方值，设定退出代码为2
5.2 方案

通过break、continue、exit在Shell脚本中实现中断与退出的功能。
break可以结束整个循环；continue结束本次循环，进入下一次循环；exit结束整个脚本，案例如下：
[root@svr5 ~]# cat  /root/test.sh
#!/bin/bash
for  i   in   {1..5}
do
       [  $i  -eq  3 ]&& break //这里将break替换为continue，exit分别测试脚本执行效果       echo $i
done
echo "Game Over"
5.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写脚本sum.sh

1）编写脚本文件
[root@svr5 ~]# vim sum.sh 
#!/bin/bash
while  read  -p  "请输入待累加的整数（0表示结束）："     x
do
    [ $x -eq 0 ]  &&  break
    SUM=$[SUM+x]
done
echo "总和是：$SUM"
[root@svr5 ~]# chmod +x chkint.sh
步骤二：编写sum.sh脚本文件

1）编写脚本文件
[root@svr5 ~]# vim mysum.sh 
#!/bin/bash
i=0
while  [ $i -le 20 ]
do
    let i++
    [ $[i%6] -ne 0 ]  &&  continue
    echo $[i*i]
done
exit 2
[root@svr5 ~]# chmod +x sum.sh

Top
NSD SHELL DAY04

案例1：字符串截取及切割
案例2：字符串初值的处理
案例3：expect预期交互
案例4：使用正则表达式



1 案例1：字符串截取及切割
1.1 问题

使用Shell完成各种Linux运维任务时，一旦涉及到判断、条件测试等相关操作时，往往需要对相关的命令输出进行过滤，提取出符合要求的字符串。
本案例要求熟悉字符串的常见处理操作，完成以下任务练习：
参考PPT示范操作，完成子串截取、替换等操作
根据课上的批量改名脚本，编写改进版renfilex.sh：能够批量修改当前目录下所有文件的扩展名，修改前/后的扩展名通过位置参数$1、$2提供
1.2 方案

子串截取的三种用法：
${变量名:起始位置:长度}
expr substr "$变量名" 起始位置 长度
echo $变量名 | cut -b 起始位置-结束位置
子串替换的两种用法：
只替换第一个匹配结果：${变量名/old/new}
替换全部匹配结果：${变量名//old/new}
字符串掐头去尾：
从左向右，最短匹配删除：${变量名#*关键词}
从左向右，最长匹配删除：${变量名##*关键词}
从右向左，最短匹配删除：${变量名%关键词*}
从右向左，最长匹配删除：${变量名%%关键词*}
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：字符串的截取

1）方法一，使用 ${}表达式
格式：${变量名:起始位置:长度}
使用${}方式截取字符串时，起始位置是从0开始的（和数组下标编号类似） 。
定义一个变量Phone，并确认其字符串长度：
[root@svr5 ~]# phone="13788768897"
[root@svr5 ~]# echo ${#phone}
11                                         //包括11个字符
使用${}截取时，起始位置可以省略，省略时从第一个字符开始截。比如，以下操作都可以从左侧开始截取前6个字符：
[root@svr5 ~]# echo ${phone:0:6}
137887
或者
[root@svr5 ~]# echo ${phone::6}
137887
因此，如果从起始位置1开始截取6个字符，那就变成这个样子了：
[root@svr5 ~]# echo ${phone:1:6}
378876
2）方法二，使用 expr substr
格式：expr substr "$变量名" 起始位置 长度
还以前面的Phone变量为例，确认原始值：
[root@svr5 ~]# echo $phone
13788768897
使用expr substr截取字符串时，起始编号从1开始，这个要注意与${}相区分。
从左侧截取Phone变量的前6个字符：
[root@svr5 ~]# expr substr "$phone" 1 6
137887
从左侧截取Phone变量的第9-11个字符：
[root@svr5 ~]# expr substr "$phone" 9 3
897
3）方式三，使用cut分割工具
格式：echo $变量名 | cut -b 起始位置-结束位置
选项 -b 表示按字节截取字符，其中起始位置、结束位置都可以省略。当省略起始位置时，视为从第1个字符开始（编号也是从1开始，与expr类似），当省略结束位置时，视为截取到最后。
还以前面的Phone变量为例，确认原始值：
[root@svr5 ~]# echo $phone
13788768897
从左侧截取前6个字符，可执行以下操作：
[root@svr5 ~]# echo $phone | cut -b 1-6
137887
从第8个字符截取到末尾：
[root@svr5 ~]# echo $phone | cut -b 8-
8897
只截取单个字符，比如第9个字符：
[root@svr5 ~]# echo $phone | cut -b 9
8
截取不连续的字符，比如第3、5、8个字符：
[root@svr5 ~]# echo $phone | cut -b 3,5,8
788
4）一个随机密码的案例
版本1：
[root@svr5 ~]# vim rand.sh
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
//所有密码的可能性是26+26+10=62（0-61是62个数字）
num=$[RANDOM%62]
pass=${x:num:1}
版本2：
[root@svr5 ~]# vim rand.sh
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
//所有密码的可能性是26+26+10=62（0-61是62个数字）
for i in {1..8}
do
num=$[RANDOM%62]
tmp=${x:num:1}
pass=${pass}$tmp
done
echo $pass
步骤二：字符串的替换

1）只替换第1个子串
格式：${变量名/old/new}
还以前面的Phone变量为例，确认原始值：
[root@svr5 ~]# echo $phone
13788768897
将字符串中的第1个8替换为XX:
[root@svr5 ~]# echo  ${phone/8/XX}
2）替换全部子串
格式：${变量名//old/new}
将phone字符串中的所有8都替换为X:
[root@svr5 ~]# echo  ${phone//8/X}
步骤三：字符串的匹配删除

以处理系统默认的账户信息为例，定义变量A：
[root@svr5 ~]# A=`head -1 /etc/passwd`
[root@svr5 ~]# echo $A
root:x:0:0:root:/root:/bin/bash
1）从左向右，最短匹配删除
格式：${变量名#*关键词}
删除从左侧第1个字符到最近的关键词“：”的部分，* 作通配符理解：
[root@svr5 ~]# echo ${A#*:}
x:0:0:root:/root:/bin/bash
2）从左向右，最长匹配删除
格式：${变量名##*关键词}
删除从左侧第1个字符到最远的关键词“:”的部分：
[root@svr5 ~]# echo $A                      //确认变量A的值
root:x:0:0:root:/root:/bin/bash
[root@svr5 ~]# echo ${A##*:}
/bin/bash
3）从右向左，最短匹配删除
格式：${变量名%关键词*}
删除从右侧最后1个字符到往左最近的关键词“:”的部分，* 做通配符理解：
[root@svr5 ~]# echo ${A%:*}
root:x:0:0:root:/root
4）从右向左，最长匹配删除
格式：${变量名%%关键词*}
删除从右侧最后1个字符到往左最远的关键词“:”的部分：
[root@svr5 ~]# echo ${A%%:*}
root
步骤四：编写renfilex.sh脚本

创建一个测试用的测试文件
[root@svr5 rendir]# touch {a,b,c,d,e,f,g,h,i}.doc
[root@svr5 rendir]# ls
a.doc  b.doc  c.doc  d.doc  e.doc  f.doc  g.doc  h.doc  i.doc
1）批量修改文件扩展模的脚本renfile.sh
脚本用途为：批量修改当前目录下的文件扩展名，将.doc改为.txt。
脚本内容参考如下：
[root@svr5 ~]# vim renfile.sh
#!/bin/bash
for FILE in `ls *.doc`
do
    mv $FILE  ${FILE%.*}.txt
done
[root@svr5 ~]# chmod +x renfile.sh
调用renfile.sh脚本，查看修改结果（原来扩展名为.doc的文件，其扩展名都变成了.txt）：
[root@svr5 rendir]# ./renfile.sh
[root@svr5 rendir]# ls
a.txt  b.txt  c.txt  d.txt  e.txt  f.txt  g.txt  h.txt  i.txt
2）建立改进版脚本renfilex.sh
通过位置变量 $1、$2提供更灵活的脚本，改进的脚本编写参考如下：
[root@svr5 rendir]# vim ./renfilex.sh
#!/bin/bash
for FILE in `ls *.$1`
do
    mv $FILE ${FILE%.*}"$2"
done
3）验证、测试改进后的脚本
将 *.doc文件的扩展名改为.txt：
[root@svr5 rendir]# ./renfilex.sh txt doc
将 *.mp4文件的扩展名改为.mkv：
[root@svr5 rendir]# ./renfilex.sh mp4 mkv
2 案例2：字符串初值的处理
2.1 问题

本案例要求编写一个脚本sumx.sh，求从1-x的和，相关要求如下：
从键盘读入x值
当用户未输入任何值时，默认按1计算
2.2 方案

通过${var:-word}判断变量是否存在，决定是否给变量赋初始值。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：认识字符串初值的最常见处理方法

1）只取值，${var:-word}
若变量var已存在且非Null，则返回 $var 的值；否则返回字串“word”，原变量var的值不受影响。
变量值已存在的情况：
[root@svr5 ~]# XX=11
[root@svr5 ~]# echo $XX              //查看原变量值
11
[root@svr5 ~]# echo ${XX:-123}      //因XX已存在，输出变量XX的值
11
变量值不存在的情况：
[root@svr5 ~]# echo ${YY:-123}      //因YY不存在，输出“123”
123
编写一个验证知识点的参考示例脚本如下：
[root@svr5 ~]# cat /root/test.sh
#!/bin/bash
read  -p   "请输入用户名:"   user
read  -p   "请输入用户名:"   pass
[ -z $user ] && exit                    //如果无用户名，则脚本退出
pass=${pass:-123456}                    //如果用户没有输入密码，则默认密码为123456
useradd  $user
echo "$pass"  | passwd   --stdin   $pass
步骤二：编写sumx.sh脚本，处理read输入的初值

用来从键盘读入一个正整数x，求从1到x的和；当用户未输入值（直接回车）时，为了避免执行出错，应为x赋初值1 。
1）脚本编写参考如下
[root@svr5 ~]# vim sumx.sh
#!/bin/bash
read -p "请输入一个正整数：" x
x=${x:-1}
i=1; SUM=0
while [ $i -le $x ]
do
    let SUM+=i
    let i++
done
echo "从1到$x的总和是：$SUM"
[root@svr5 ~]# chmod +x sumx.sh
2）验证、测试脚本执行效果：
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：25                          //输入25，正常读入并计算、输出结果
从1到25的总和是：325
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：70                         //输入70，正常读入并计算、输出结果
从1到70的总和是：2485
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：                          //直接回车，设x=1后计算、输出结果
从1到1的总和是：1
3 案例3：expect预期交互
3.1 问题

本案例要求编写一个expect脚本，实现SSH登录的自动交互：
提前准备好目标主机，IP地址为192.168.4.5
用户名为mike、密码为1234567
执行脚本后自动登入，并且在目标主机建立测试文件 /tmp/mike.txt
3.2 方案

expect可以为交互式过程（比如FTP、SSH等登录过程）自动输送预先准备的文本或指令，而无需人工干预。触发的依据是预期会出现的特征提示文本。
储备知识（发送邮件的几种方式）：
[root@svr5 ~]# echo "test mail" | mail -s test root
[root@svr5 ~]# mail -s test root < /etc/passwd
[root@svr5 ~]# mail -s test root << EOF
test mail
hell world
EOF
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备expect及SSH测试环境

1）安装expect工具
[root@svr5 ~]# yum  -y  install  expect                  //安装expect
.. ..
Installed:
  expect.x86_64 0:5.44.1.15-5.el6_4                                                            
Dependency Installed:
  tcl.x86_64 1:8.5.7-6.el6 
[root@svr5 ~]# which expect                              //确认expect路径
/usr/bin/expect
步骤二：编写expect_ssh脚本，实现免交互登录

1）任务需求及思路分析
在SSH登录过程中，如果是第一次连接到该目标主机，则首先会被要求接受密钥，然后才提示输入密码：
[root@svr5 ~]# ssh mike@192.168.4.5                              //连接目标主机
The authenticity of host '192.168.4.5 (192.168.4.5)' can't be established.
RSA key fingerprint is 58:a0:d6:00:c7:f1:34:5d:6c:6d:70:ce:e0:20:f8:f3.
Are you sure you want to continue connecting (yes/no)? yes          //接受密钥
Warning: Permanently added '192.168.4.5' (RSA) to the list of known hosts.
mike@192.168.4.5's password:                                   //验证密码
Last login: Thu May  7 22:05:44 2015 from 192.168.4.5
[mike@svr5 ~]$ exit                                             //返回客户端
logout
Connection to 192.168.4.5 closed.
当然，如果SSH登录并不是第一次，则接受密钥的环节就没有了，而是直接进入验证密码的过程：
[root@svr5 ~]# ssh mike@192.168.4.5                              //连接目标主机
mike@192.168.4.5's password:                                   //验证密码
Last login: Mon May 11 12:02:39 2015 from 192.168.4.5
[mike@svr5 ~]$ exit                                             //返回客户端
logout
Connection to 192.168.4.5 closed.
2）根据实现思路编写脚本文件
脚本内容参考如下版本1：
[root@svr5 ~]# vim  expect_ssh.sh 
#!/bin/bash
expect << EOF
spawn ssh 172.25.0.10                               #//创建交互式进程
expect "password:" { send "123456\r" }              #//自动发送密码
expect "#   { send "pwd > /tmp/$user.txt \r" }      #//发送命令
expect "#"  { send "exit\r" }
EOF
[root@svr5 ~]# chmod  +x  expect_ssh.sh 
通过循环批量操作，版本2：
[root@svr5 ~]# vim  expect_ssh.sh 
#!/bin/bash
for i in 10 11
do
expect << EOF
spawn ssh 172.25.0.$i                               #//创建交互式进程
expect "password:" { send "123456\r" }              #//自动发送密码
expect "#   { send "pwd > /tmp/$user.txt \r" }      #//发送命令
expect "#"  { send "exit\r" }
EOF
done
[root@svr5 ~]# chmod  +x  expect_ssh.sh 
注意事项：
expect脚本的最后一行默认不执行
如果不希望ssh时出现yes/no的提示，远程时使用如下选项:
# ssh -o StrictHostKeyChecking=no server0
4 案例4：使用正则表达式
4.1 问题

本案例要求熟悉正则表达式的编写，完成以下任务：
利用egrep工具练习正则表达式的基本用法
提取出httpd.conf文件的有效配置行
编写正则表达式，分别匹配MAC地址、E-Mail邮箱地址
4.2 方案

表－1 基本正则列表

正则符号	描述
^		开始
$		结尾
[ ] 		集合，匹配集合中的任意单个字符
[^]		对集合取反
.		匹配任意单个字符
*		匹配前一个字符任意次数[*不允许单独使用]
.*		任意所有
\{n,m\}	匹配前一个字符n到m次
\{n,\}	匹配前一个字符n次及以上
\{n\}		匹配前一个字符n次
\(\)		保留


表－1 扩展正则列表
正则符号	描述
+		前面的最少匹配一次
？		前面的最多匹配一次（0或1次）
{n,m}		匹配n到m次
()		组合为整体，保留
|		或者
\b		单词边界

基本正则：兼容性强，书写麻烦
扩展正则：书写简单，兼容性差

单词边界：
[root@room9pc01 ~]# egrep "\bthe\b" /root/tmp.txt 
afjl;sajlhklhk the jaldfj;laf
[root@room9pc01 ~]# egrep "the\b" /root/tmp.txt 
afjl;sajlhklhk the jaldfj;laf
lasdfasjlthe jladfj
[root@room9pc01 ~]# egrep "\bthe" /root/tmp.txt 
thealdajf lajsf
afjl;sajlhklhk the jaldfj;laf

grep也可以实现（有人不能）

4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：正则表达式匹配练习

1）典型的应用场合：grep、egrep检索文本行
使用不带-E选项的grep命令时，支持基本正则匹配模式。比如“word”关键词检索、“^word”匹配以word开头的行、“word$”匹配以word结尾的行……等等。
输出以“r”开头的用户记录：
[root@svr5 ~]# grep '^r' /etc/passwd
root:x:0:0:root:/root:/bin/bash
rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
输出以“localhost”结尾的行：
[root@svr5 ~]# grep 'localhost$' /etc/hosts
127.0.0.1               localhost.localdomain localhost
若希望在grep检索式同时组合多个条件，比如输出以“root”或者以“daemon”开头的行，这时候基本正则就不太方便了（“或者”必须转义为“\|”）：
[root@svr5 ~]# grep '^root|^daemon' /etc/passwd          //搜索无结果
[root@svr5 ~]#
[root@svr5 ~]# grep '^root\|^daemon' /etc/passwd          //正确获得结果
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
而若若使用grep -E或egrep命令，可支持扩展正则匹配模式，能够自动识别 |、{ 等正则表达式中的特殊字符，用起来更加方便，比如：
[root@svr5 ~]# grep -E '^root|^daemon' /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
或者
[root@svr5 ~]# egrep '^root|^daemon' /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
使用grep -E 与 使用egrep命令完全等效，推荐使用后者，特别是涉及到复杂的正则表达式的时候。
2）grep、egrep命令的-q选项
选项 -q 表示 quiet（静默）的意思，结合此选项可以只做检索而并不输出，通常在脚本内用来识别查找的目标是否存在，通过返回状态 $? 来判断，这样可以忽略无关的文本信息，简化脚本输出。
比如，检查/etc/hosts文件内是否存在192.168.4.4的映射记录，如果存在则显示“YES”，否则输出“NO”，一般会执行：
[root@svr5 ~]# grep '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
192.168.4.4     svr5.tarena.com svr5
YES
这样grep的输出信息和脚本判断后的提示混杂在一起，用户不易辨别，所以可以改成以下操作：
[root@svr5 ~]# grep -q '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
YES
是不是清爽多了，从上述结果也可以看到，使用 -q 选项的效果与使用 &> /dev/null的效果类似。
3）基本元字符 ^、$ —— 匹配行首、行尾
输出默认运行级别的配置记录（以id开头的行）：
[root@svr5 ~]# egrep '^id' /etc/inittab
id:3:initdefault:
输出主机名配置记录（以HOSTNAME开头的行）：
[root@svr5 ~]# egrep '^HOSTNAME' /etc/sysconfig/network
HOSTNAME=svr5.tarena.com
统计本地用户中登录Shell为“/sbin/nologin”的用户个数：
[root@svr5 ~]# egrep -m10 '/sbin/nologin$' /etc/passwd  //先确认匹配正确
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
[root@svr5 ~]# egrep -c '/sbin/nologin$' /etc/passwd
32                                      //结合 -c 选项输出匹配的行数
使用 -c 选项可输出匹配行数，这与通过管道再 wc -l的效果是相同的，但是写法更简便。比如，统计使用“/bin/bash”作为登录Shell的正常用户个数，可执行：
[root@svr5 ~]# egrep -c '/bin/bash$' /etc/passwd
26
或者
[root@svr5 ~]# egrep '/bin/bash$' /etc/passwd | wc -l
26
4）基本元字符 . —— 匹配任意单个字符
以/etc/rc.local文件为例，确认文本内容：
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出/etc/rc.local文件内至少包括一个字符（\n换行符除外）的行，即非空行：
[root@svr5 ~]# egrep '.' /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出/etc/rc.local文件内的空行（用 –v 选项将条件取反）：
[root@svr5 ~]# egrep -v '.' /etc/rc.local
[root@svr5 ~]#
上述取空行的操作与下列操作效果相同：
[root@svr5 ~]# egrep '^$' /etc/rc.local
[root@svr5 ~]#
5）基本元字符 +、?、* —— 目标出现的次数
还以/etc/rc.local文件为例：
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出包括 f、ff、ff、……的行，即“f”至少出现一次：
[root@svr5 ~]# egrep 'f+' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
输出包括init、initial的行，即末尾的“ial”最多出现一次（可能没有）：
[root@svr5 ~]# egrep 'init(ial)?' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
输出包括stu、stuf、stuff、stufff、……的行，即末尾的“f”可出现任意多次，也可以没有。重复目标只有一个字符时，可以不使用括号：
[root@svr5 ~]# egrep 'stuf*' /etc/rc.local
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
输出所有行，单独的“.*”可匹配任意行（包括空行）：
[root@svr5 ~]# egrep '.*' /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出/etc/passwd文件内“r”开头且以“nologin”结尾的用户记录，即中间可以是任意字符：
[root@svr5 ~]# egrep '^r.*nologin$' /etc/passwd
rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
6）元字符 {} —— 限定出现的次数范围
创建一个练习用的测试文件：
[root@svr5 ~]# vim brace.txt
ab def ghi abdr
dedef abab ghighi
abcab CD-ROM
TARENA IT GROUP
cdcd ababab
Hello abababab World
输出包括ababab的行，即“ab”连续出现3次：
[root@svr5 ~]# egrep '(ab){3}' brace.txt
cdcd ababab
Hello abababab World
输出包括abab、ababab、abababab的行，即“ab”连续出现2~4次：
[root@svr5 ~]# egrep '(ab){2,4}' brace.txt
dedef abab ghighi
cdcd ababab
Hello abababab World
输出包括ababab、abababab、……的行，即“ab”最少连续出现3次：
[root@svr5 ~]# egrep '(ab){3,}' brace.txt
cdcd ababab
Hello abababab World
7）元字符 [] —— 匹配范围内的单个字符
还以前面的测试文件bracet.txt为例：
[root@svr5 ~]# cat brace.txt
ab def ghi abdr
dedef abab ghighi
abcab CD-ROM
TARENA IT GROUP
cdcd ababab
Hello abababab World
输出包括abc、abd的行，即前两个字符为“ab”，第三个字符只要是c、d中的一个就符合条件：
[root@svr5 ~]# egrep 'ab[cd]' brace.txt
ab def ghi abdr
abcab CD-ROM
输出包括大写字母的行，使用[A-Z]匹配连续范围：
[root@svr5 ~]# egrep '[A-Z]' brace.txt
abcab CD-ROM
TARENA IT GROUP
Hello abababab World
输出包括“非空格也非小写字母”的其他字符的行，本例中大写字母和 – 符合要求：
[root@svr5 ~]# egrep '[^ a-zA-Z]' brace.txt
abcab CD-ROM
8）单词边界匹配
以文件/etc/rc.local为例：
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出包括单词“init”的行，文件中“initialization”不合要求：
[root@svr5 ~]# egrep '\binit\b' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
或者：
[root@svr5 ~]# egrep '\<init\>' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
输出包括以“ll”结尾的单词的行，使用 \> 匹配单词右边界：
[root@svr5 ~]# egrep 'll\>' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
或者：
[root@svr5 ~]# egrep 'll\b' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
9）多个条件的组合
通过dmesg启动日志查看蓝牙设备、网卡设备相关的信息：
[root@svr5 ~]# egrep -i 'eth|network|bluetooth' /var/log/dmesg
Initalizing network drop monitor service
Bluetooth: Core ver 2.10
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: HCI USB driver ver 2.9
Intel(R) PRO/1000 Network Driver - version 7.3.21-k4-3-NAPI
e1000: eth0: e1000_probe: Intel(R) PRO/1000 Network Connection
步骤二：利用正则表达式完成检索任务

1）提取出httpd.conf文件的有效配置行
以RHEL6自带的httpd软件包为例，默认的httpd.conf配置文件内提供了大量的注释信息（# 开头或空几个格再 #），以及一些分隔的空行：
[root@svr5 ~]# head  /etc/httpd/conf/httpd.conf  //确认文件内容
#
# This is the main Apache server configuration file.  It contains the
# configuration directives that give the server its instructions.
# See <URL:http://httpd.apache.org/docs/2.2/> for detailed information.
# In particular, see
# <URL:http://httpd.apache.org/docs/2.2/mod/directives.html>
# for a discussion of each configuration directive.
#
#
# Do NOT simply read the instructions in here without understanding
[root@svr5 ~]# egrep -c ".*" /etc/httpd/conf/httpd.conf
991                                              //总行数
[root@svr5 ~]# egrep -c "#" /etc/httpd/conf/httpd.conf
674                                              //含注释的行数
[root@svr5 ~]# egrep -c "^$" /etc/httpd/conf/httpd.conf
95                                                  //空行的数量
提取有效配置行，也就是说应排除掉注释行、空行，根据上面的结果可得知有效配置行的数量应该是“991-674-95=222”，确认一下：
[root@svr5 ~]# egrep -c -v '#|^$'  /etc/httpd/conf/httpd.conf
222
结合 > 重定向操作，提取httpd.conf的有效配置，将其保存到文件 httpd.conf.min，相关操作如下：
[root@svr5 ~]# egrep -v '#|^$'  /etc/httpd/conf/httpd.conf > httpd.conf.min
[root@svr5 ~]# head httpd.conf.min          //确认有效配置的前10行
ServerTokens OS
ServerRoot "/etc/httpd"
PidFile run/httpd.pid
Timeout 120
KeepAlive Off
MaxKeepAliveRequests 100
KeepAliveTimeout 15
<IfModule prefork.c>
StartServers       8
MinSpareServers    5
2）匹配MAC地址、邮箱地址
以使用ifconfig查看的结果为例，MAC地址的特征是以“:”分隔的6组十六进制数，每组由2个字符组成，比如：
[root@svr5 ~]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0C:29:82:09:E9
          inet addr:192.168.4.4  Bcast:192.168.4.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe82:9e9/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:177666 errors:0 dropped:0 overruns:0 frame:0
          TX packets:101720 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:18454015 (17.5 MiB)  TX bytes:13467792 (12.8 MiB)
采用正则表达式匹配“00:0C:29:82:09:E9”形式的MAC地址，可以写成：
[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}
或者：
[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}
其中，[0-9a-fA-F]{2} 表示一段十六进制数值，第二种方式的{5}表示连续出现5组前置 : 的十六进制。
因此，若要从ifconfig eth0的输出结果中过滤出包含MAC地址值的行，可以执行以下操作：
[root@svr5 ~]# ifconfig eth0 | egrep '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'
eth0      Link encap:Ethernet  HWaddr 00:0C:29:82:09:E9
或者：
[root@svr5 ~]# ifconfig eth0 | egrep \
'[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}'
eth0      Link encap:Ethernet  HWaddr 00:0C:29:82:09:E9
根据上述操作结果，稍微扩展一下。利用MAC匹配条件，可以检查一个变量的值是否是合法的MAC地址。参考下列操作：
先定义三个变量：
[root@svr5 ~]# MAC01="00:50:56:C0:00:08"
[root@svr5 ~]# MAC02="20:68:9D:48:C4:98"
[root@svr5 ~]# MAC03="20:69:74:R2:C5:27"              //设一个无效地址
利用正则表达式判断出其中哪个MAC地址是无效的：
[root@svr5 ~]# echo $MAC01 | egrep -q \
'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}' && echo "有效" || echo "无效"
有效
[root@svr5 ~]# echo $MAC02 | egrep -q \
'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}' && echo "有效" || echo "无效"
有效
[root@svr5 ~]# echo $MAC03 | egrep -q \
'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}' && echo "有效" || echo "无效"
无效
3）匹配邮箱地址
电子邮箱地址的特征是“用户名@域名”，主要包括：
用户名与域名之间以 @ 分隔
用户名不少于3个字符，可能由字母、下划线、句点 . 、数字组成
域名应至少有一个 . 分隔，分隔的各部分至少2个字符，可能由字母、减号、数字组成
根据上述特点，编写的正则表达式参考如下：其中域名分隔以“\.”表示，不能表示为 . ，否则会匹配任意单个字符。
[0-9a-zA-Z_.]{3,}@[0-9a-zA-Z-]{2,}(\.[0-9a-zA-Z-]{2,})+
创建一个测试文件，添加若干行主机名、Email、域名地址：
[root@svr5 ~]# vim mailadd.txt
www.tarena.com.cn
mail.163.com
hackli@gmail.com
qq.com
www.sina.com.cn
baidu.com
root@tarena.com
bill@microsoft                          //无效的邮箱地址，用作测试
suen11_20@163.com
过滤出上述文件中包含有效Email地址的行：
[root@svr5 ~]# egrep '[0-9a-zA-Z_.]{3,}@\
[0-9a-zA-Z.-]{2,}(\.[0-9a-zA-Z-]{2,})+' mailadd.txt
hackli@gmail.com
root@tarena.com.cn
suen11_20@163.com
Top
NSD SHELL DAY05

案例1：sed基本用法
案例2：使用sed修改系统配置
案例3：sed多行文本处理
案例4：sed综合脚本应用
1 案例1：sed基本用法
1.1 问题

本案例要求熟悉sed命令的p、d、s等常见操作，并结合正则表达式，完成以下任务：
删除文件中每行的第二个、最后一个字符
将文件中每行的第一个、第二个字符互换
删除文件中所有的数字
为文件中每个大写字母添加括号


！！！逐行处理
1.2 方案

sed文本处理工具的用法：

用法1：前置命令 | sed  [选项]  '条件指令'
用法2：sed  [选项]  '条件指令'  文件.. ..

相关说明如下：
条件可以是行号或者/正则/
没有条件时，默认为所有条件
指令可以是增、删、改、查等指令
默认sed会将所有输出的内容都打印出来，可以使用-n屏蔽默认输出
选项中可以使用-r选项，让sed支持扩展正则
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：认识sed工具的基本选项

sed命令的常用选项如下：sed默认会把源文件全部输出
-n（屏蔽默认输出，默认sed会输出读取文档的全部内容）

-r（让sed支持扩展正则）

-i（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）
1）sed命令的 -n 选项
执行p打印等过滤操作时，希望看到的是符合条件的文本。但不使用任何选项时，默认会将原始文本一并输出，从而干扰过滤效果。比如，尝试用sed输出/etc/hosts的第1行：
[root@svr5 ~]# sed '1p' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
可以发现所有的行都被显示出来了（第1行重复2次）。—— 正确的用法应该添加 -n 选项，这样就可以只显示第1行了：
[root@svr5 ~]# sed -n '1p' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
行号可以是连续的行号，如打印passwd第3到第6行账户的信息：
[root@svr5 ~]# sed  -n '3,6p' /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
2）sed命令的 -i 选项
正常情况下，sed命令所做的处理只是把操作结果（包括打印、删除等）输出到当前终端屏幕，而并不会对原始文件做任何更改：
[root@svr5 ~]# sed 'd' /etc/passwd                      //删除所有行
[root@svr5 ~]# cat /etc/passwd                          //查看原始文本，并未改动
若希望直接修改文件内容，应添加选项 -i 。
比如，直接删除test.txt（自行创建一个任意内容的文件）的第1~4行，不输出结果：
[root@svr5 ~]# sed -i '1,4d' test.txt            //删除操作
[root@svr5 ~]# cat test.txt                      //确认删除结果
下文中关于使用sed修改文件的示例中，为了避免大家在练习过程中因误操作导致系统故障，命令省略 –i 选项，不再逐一说明。需要时，大家可自行加上此选项。
3）多个指令可以使用分号隔离
用分号来隔离多个操作，比如：
[root@svr5 ~]# sed -n '1p;4p' /etc/passwd
root:x:0:0:root:/root:/bin/bash
adm:x:3:4:adm:/var/adm:/sbin/nologin
步骤二：认识sed工具的条件

# sed [选项] '条件指令' 文件.. ..
sed命令可以使用行号或正则做为条件匹配：
1）行号案例
打印第3行：
[root@svr5 ~]# sed -n '3p' /etc/passwd
打印第3到5行：
[root@svr5 ~]# sed -n '3,5p' /etc/passwd
打印第3和5行：
[root@svr5 ~]# sed -n '3p;5p' /etc/passwd
打印第3以及后面的10行：
[root@svr5 ~]# sed -n '3,+10p' /etc/passwd
打印奇数行：
[root@svr5 ~]# sed -n '1~2p' /etc/passwd
打印偶数行：
[root@svr5 ~]# sed -n '2~2p' /etc/passwd
2）正则案例
打印包含root的行：
[root@svr5 ~]# sed -n '/root/p' /etc/passwd
打印bash结尾的行：
[root@svr5 ~]# sed -n '/bash$/p' /etc/passwd
步骤三：sed工具的p、d、s操作指令案例集合

1）下面看看sed工具的p指令案例集锦（提前生成一个a.txt文件）
[root@svr5 ~]# sed  -n 'p' a.txt            //输出所有行，等同于cat a.txt
[root@svr5 ~]# sed  -n '4p' a.txt            //输出第4行
[root@svr5 ~]# sed  -n '4,7p' a.txt        //输出第4~7行
[root@svr5 ~]# sed  -n '4,+10p' a.txt        //输出第4行及其后的10行内容
[root@svr5 ~]# sed  -n '/^bin/p' a.txt        //输出以bin开头的行
[root@svr5 ~]# sed  -n '$=' a.txt            //输出文件的行数，输出最后一行的行号
2）下面看看sed工具的d指令案例集锦（提前生成一个a.txt文件）
[root@svr5 ~]# sed  '3,5d' a.txt             //删除第3~5行
[root@svr5 ~]# sed  '/xml/d' a.txt            //删除所有包含xml的行
[root@svr5 ~]# sed  '/xml/!d' a.txt         //删除不包含xml的行，!符号表示取反
[root@svr5 ~]# sed  '/^install/d' a.txt    //删除以install开头的行
[root@svr5 ~]# sed  '$d' a.txt                //删除文件的最后一行
[root@svr5 ~]# sed  '/^$/d' a.txt             //删除所有空行
3）sed命令的s替换基本功能（s/旧内容/新内容/选项）：
[root@svr5 ~]# vim  test.txt                //新建素材
2017 2011 2018
2017 2017 2024
2017 2017 2017
[root@svr5 ~]# sed 's/2017/xxxx/'           test.txt
[root@svr5 ~]# sed '2s/2017/xxxx/'           test.txt	###第二行的2017替换
[root@svr5 ~]# sed 's/2017/xxxx/g'          test.txt
[root@svr5 ~]# sed 's/2017/xxxx/2'          test.txt	###替换第二个2017
[root@svr5 ~]# sed 's/2017//2'              test.txt	##把2017换成空，相当于删除
[root@svr5 ~]# sed -n 's/2017/xxxx/p'      test.txt

[root@server0 ~]# ifconfig eth0 | sed -n '2s/netma.*//p' | sed 's/inet//'
         172.25.0.1



4）下面看看sed工具的s指令案例集锦（提前生成一个a.txt文件）
注意：替换操作的分隔“/”可改用其他字符，如#、&等，便于修改文件路径
[root@svr5 ~]# sed 's/xml/XML/'  a.txt        //将每行中第一个xml替换为XML
[root@svr5 ~]# sed 's/xml/XML/3' a.txt     //将每行中的第3个xml替换为XML
[root@svr5 ~]# sed 's/xml/XML/g' a.txt     //将所有的xml都替换为XML
[root@svr5 ~]# sed 's/xml//g'     a.txt     //将所有的xml都删除（替换为空串）
[root@svr5 ~]# sed 's#/bin/bash#/sbin/sh#' a.txt  //将/bin/bash替换为/sbin/sh
[root@svr5 ~]# sed '4,7s/^/#/'   a.txt         //将第4~7行注释掉（行首加#号）
[root@svr5 ~]# sed 's/^#an/an/'  a.txt         //解除以#an开头的行的注释（去除行首的#号）
步骤四：利用sed完成本例要求的任务

参考数据文件内容如下：
[root@svr5 ~]# cat nssw.txt
Hello the world
ni hao ma beijing
本小节的操作使用nssw.txt作为测试文件。
1）删除文件中每行的第二个、最后一个字符
分两次替换操作，第一次替换掉第2个字符，第二次替换掉最后一个字符：
[root@svr5 ~]# sed 's/.//2 ; s/.$//' nssw.txt 
2）将文件中每行的第一个、倒数第1个字符互换
每行文本拆分为“第1个字符”、“中间的所有字符”、“倒数第1个字符”三个部分，然后通过替换操作重排顺序为“3-2-1”：
[root@svr5 ~]# sed -r 's/^(.)(.*)(.)$/\3\2\1/' nssw.txt
3）删除文件中所有的数字
因原文件内没有数字，行首也没有空格，这里稍作做一点处理，生成一个新测试文件：
[root@svr5 ~]# sed 's/[0-9]//' nssw.txt
以nssw2.txt文件为例，删除所有数字、行首空格的操作如下：
[root@svr5 ~]# sed -r 's/[0-9]//g;s/^( )+//' nssw2.txt
4）为文件中每个大写字母添加括号
使用“（）”可实现保留功能，所以可参考下列操作解决：
[root@svr5 ~]# sed 's/([A-Z])/[\1]/g' nssw.txt
2 案例2：使用sed修改系统配置
2.1 问题

本案例要求熟悉课上的sed应用案例，并编写脚本anonftp.sh，实现以下功能：
通过yum安装vsftpd软件包
修改vsftpd服务配置，开启匿名上传
调整/var/ftp/pub目录权限，允许ftp写入
启动vsftpd服务，并设置开机自运行
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写anonftp.sh脚本，用来装配匿名FTP服务

1）任务需求及思路分析
vsftpd服务的安装、改目录权限、起服务等操作可以直接写在脚本中。
修改vsftpd.conf配置的工作可以使用sed命令，根据默认配置，只需要定位到以#anon开头的行，去掉开头的注释即可。
2）根据实现思路编写脚本文件
[root@svr5 ~]# vim anonftp.sh
#!/bin/bash
yum -y install vsftpd                             //安装vsftpd软件
cp /etc/vsftpd/vsftpd.conf{,.bak}                  //备份默认的配置文件
sed -i "/^#anon/s/^#//" /etc/vsftpd/vsftpd.conf      //修改服务配置
chown ftp /var/ftp/pub                              //调整目录权限
systemctl start vsftpd                              //启动服务
systemctl enable vsftpd                            //设为自动运行
[root@svr5 ~]# chmod +x anonftp.sh
3 案例3：sed多行文本处理
3.1 问题

本案例要求使用sed工具来完成下列任务操作：
修改主机名配置文件
修改hosts文件，添加两条映射记录：192.168.4.5 与 svr5.tarena.com、svr5，还有119.75.217.56与www.baidu.com
3.2 方案

# sed [选项] '条件指令' 文件..
sed工具的多行文本处理操作：
i： 在指定的行之前插入文本
a：在指定的行之后追加文本
c：替换指定的行
3.3 步骤

基本语法格式案例：
[root@svr5 ~]# sed  '2a XX'   a.txt            //在第二行后面，追加XX
[root@svr5 ~]# sed  '2i XX'   a.txt            //在第二行前面，插入XX
[root@svr5 ~]# sed  '2c XX'   a.txt            //将第二行替换为XX
实现此案例需要按照如下步骤进行。
步骤一：修改主机名配置文件

1）确认修改前的配置
[root@svr5 ~]# cat /etc/hostname
svr5.tarena.com
2）使用sed修改主机名配置所在行的内容（c整行替换）
[root@svr5 ~]# sed  '1c mysvr.tarena.com' /etc/hostname 
步骤二：修改hosts文件，添加新的记录

1）确认修改前的配置
[root@svr5 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
2）使用sed修改hosts文件，添加两行新纪录（a追加）
[root@svr5 ~]# sed  -i  '$a 192.168.4.5  svr5.tarena.com svr5'  /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.4.5  svr5.tarena.com svr5
4 案例4：sed综合脚本应用
4.1 问题

本案例要求编写脚本getupwd.sh，实现以下需求：
找到使用bash作登录Shell的本地用户
列出这些用户的shadow密码记录
按每行“用户名 --> 密码记录”保存到getupwd.log，如图-1所示

图－1
4.2 方案

基本思路如下：
先用sed工具取出登录Shell为/bin/bash的用户记录，保存为临时文件/tmp/urec.tmp，并计算记录数量
再结合while循环遍历取得的账号记录，逐行进行处理
针对每一行用户记录，采用掐头去尾的方式获得用户名、密码字串
按照指定格式追加到/tmp/getuupwd.log文件
结束循环后删除临时文件，报告分析结果
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写getupwd.sh脚本

[root@svr5 ~]# vim ./getupwd.sh  
#/bin/bash
A=$(sed -n '/bash$/s/:.*//p' /etc/passwd)             ## 提取符合条件的账号记录
for i in  $A                                         ##遍历账号记录
do
    pass1=$(grep $i /etc/shadow)
    pass2=${pass1#*:}
    pass=${pass2%%:*}
    echo  "$i   --> $pass"
done
[root@svr5 ~]# chmod +x ./getupwd.sh 
步骤二：测试、验证执行结果

[root@svr5 ~]# ./getupwd.sh     
用户分析完毕，请查阅文件 /tmp/getupwd.log
[root@svr5 ~]# less /tmp/getupwd.log 
root --> $6$IWgMYmRACwdbfwBo$dr8Yn983nswiJVw0dTMjzbDvSLeCd1GMYjbvsDiFEkL8jnXOLcocBQypOCr4C6BRxNowIxjh6U2qeFU0u1LST/
zengye --> $6$Qb37LOdzRl5995PI$L0zTOgnhGz8ihWkW81J.5XhPp/l7x2./Me2ag0S8tRndCBL9nIjHIKkUKulHxJ6TXyHYmffbVgUT6pbSwf8O71
clamav --> !!
mysql --> !!
abc --> !!
.. ..
从上述参考脚本可以发现，使用sed来实现字段提取会比较复杂。下一章课程将会学到awk命令，届时可以通过更简单的方法来改进此脚本内容。
总结知识点：
#sed [选项] '条件指令' 文件

[root@server0 ~]# sed '2r /etc/hosts' test.txt
after the 2nd line,read /etc/hosts 

[root@server0 ~]# sed '2w /etc/hosts' test.txt
the 2nd line of test.txt  write in /etc/hosts(over soure)

选项:
-n 屏蔽默认输出
-r 支持扩展正则
-i 修改源文件
条件：
行号 4 4,5 4~2 4,+10
/正则/
指令：
p 打印
d 删除
s 替换s/旧/新/g
a 追加
i 插入
c 替换行

sed 的复制 粘贴
- 模式空间
	存放当前处理的行，将处理结果输出
	若当前行不符合处理条件，则原样输出
	处理完当前行再读入下一行来处理
- 保持空间
	作用类似于“剪贴板”
	默认存放一个空行(换行符 \n)

-H:模式空间--[追加]-->保持空间   复制行n到保留空间
-h:模式空间--[覆盖]-->保持空间
-G:保持空间--[追加]-->模式空间
-g:保持空间--[覆盖]-->模式空间

cat a.txt
1
2
3
4
5
6
sed '3H;5G' a.txt
1
2
3
4
5

3
6
将第三行的内容复制到第5行后面同加一个回车

sed '3h;5g' a.txt
1
2
3
4
3
6

把第1-3行复制到文件末尾
sed '1,3H;$G' a.txt
sed '1h;2,3H;$G' a.txt 可避免出现空行





Top
NSD SHELL DAY06

案例1：使用awk提取文本
案例2：awk处理条件
案例3：awk综合脚本应用
案例4：awk流程控制
案例5：awk扩展应用
1 案例1：使用awk提取文本
1.1 问题

本案例要求使用awk工具完成下列过滤任务：
练习awk工具的基本用法
提取本机的网卡流量、根分区剩余容量、获取SSH远程失败的IP地址
格式化输出/etc/passwd文件中的用户名、UID、宿主目录信息
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：awk文本过滤的基本用法

1）基本操作方法
格式：awk [选项] '[条件]{指令}' 文件
其中，print 是最常用的编辑指令；若有多条编辑指令，可用分号分隔。
Awk过滤数据时支持仅打印某一列，如第2列、第5列等。
处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。
直接过滤文件内容：
[root@svr5 ~]# cat test.txt 
hello the world
welcome to beijing
[root@svr5 ~]# awk '{print $1,$3}' test.txt        //打印文档第1列和第3列
hello world
welcome beijing
结合管道过滤命令输出：
[root@svr5 ~]# df -h | awk '{print $4}'        //打印磁盘的剩余空间
2）选项 -F 可指定分隔符
输出passwd文件中以分号分隔的第1、7个字段，显示的不同字段之间以逗号隔开，操作如下：
[root@svr5 ~]# awk -F: '{print $1,$7}' /etc/passwd
root /bin/bash
bin /sbin/nologin
daemon /sbin/nologin
adm /sbin/nologin
lp /sbin/nologin
sync /bin/sync
shutdown /sbin/shutdown
awk还识别多种单个的字符，比如以“:”或“/”分隔，输出第1、10个字段：
[root@svr5 ~]# awk -F [:/] '{print $1,$10}' /etc/passwd
root bash
bin nologin
daemon nologin
adm sbin
lp
sync sync
shutdown shutdown
awk常用内置变量：
$0	文本的整行
$1	文本的第1列
$2	文件的第2列
$3	文件的第3列，依此类推
NR	文件当前行的行号
NF	文件当前行的列数（有几列）
输出每次处理的行号，以及当前行以“:”分隔的字段个数：
[root@svr5 ~]# awk -F: '{print NR,NF}' passwd.txt
1 7
2 7
3 7
4 7
.. ..
[root@svr5 ~]# awk -F: '{print $NF}' passwd.txt
读取每一行的最后一列




2）awk的print指令不仅可以打印变量，还可以打印常量
[root@svr5 ~]# awk -F: '{print $1,"的解释器:",$7}' /etc/passwd
root 的解释器: /bin/bash
bin 的解释器: /sbin/nologin
… …
步骤二：利用awk提取本机的网络流量、根分区剩余容量、获取远程失败的IP地址

1）提取IP地址
分步实现的思路及操作参考如下——
通过ifconfig eth0查看网卡信息，其中包括网卡流量：
[root@svr5 ~]# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.21  netmask 255.255.255.0  broadcast 192.168.4.255
        inet6 fe80::fa64:c143:ad6a:5159  prefixlen 64  scopeid 0x20<link>
        ether 52:54:00:b3:11:11  txqueuelen 1000  (Ethernet)
        RX packets 313982  bytes 319665556 (304.8 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 51809  bytes 40788621 (38.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
RX为接收的数据量，TX为发送的数据量。packets以数据包的数量为单位，bytes以字节为单位：
[root@svr5 ~]# ifconfig eth0 | awk '/RX p/{print $5}'    //过滤接收数据的流量
319663094
[root@svr5 ~]# ifconfig eth0 | awk '/TX p/{print $5}'     //过滤发送数据的流量
40791683
2）提取根分区剩余容量
分步实现的思路及操作参考如下——
通过df命令查看根分区的使用情况，其中包括剩余容量：
[root@svr5 ~]# df -h /
文件系统             容量     已用     可用     已用%     挂载点
/dev/sda2         19G         7.2G     11G         40%         /
输出上述结果中最后一行的第4列：
[root@svr5 ~]# df -h / | tail -1 | awk '{print $6}'
11G
或者直接在awk中使用正则：
[root@svr5 ~]# df -h | awk '/\/$/{print $4}'
11G
3）根据/var/log/secure日志文件，过滤远程连接密码失败的IP地址
[root@svr5 ~]# awk '/Failed/{print $11}' /var/log/secure
192.168.2.254
192.168.2.100
... ...
在/var/www/cgi-bin/下建立test.sh 可以把本机的ip和內存，

步骤三：格式化输出/etc/passwd文件

1）awk处理的时机
awk会逐行处理文本，支持在处理第一行之前做一些准备工作，以及在处理完最后一行之后做一些总结性质的工作。在命令格式上分别体现如下：
awk  [选项]  ' BEGIN{指令} {指令} END{指令}'  文件
BEGIN{ }	行前处理，读取文件内容前执行，指令执行1次
{ }	逐行处理，读取文件过程中执行，指令执行n次
END{ }	行后处理，读取文件结束后执行，指令执行1次
只做预处理的时候，可以没有操作文件，比如：
[root@svr5 ~]# awk 'BEGIN{A=24;print A*2}'
[root@svr5 ~]# awk 'BEGIN{print x+1}'
[root@svr5 ~]# awk 'BEGIN{print 3.2+3.5}'
举个例子（统计系统中使用bash作为登录Shell的用户总个数）：
a.预处理时赋值变量x=0
b.然后逐行读入/etc/passwd文件，如果发现登录Shell是/bin/bash则x加1
c.全部处理完毕后，输出x的值即可。相关操作及结果如下：
[root@svr5 ~]# awk 'BEGIN{x=0}/bash$/{x++} END{print x}' /etc/passwd
29

!!!在awk中，如果设置的变量不存在，则默认认为是0


2）格式化输出/etc/passwd文件
要求: 格式化输出passwd文件内容时，要求第一行为列表标题，中间打印用户的名称、UID、家目录信息，最后一行提示一共已处理文本的总行数，如图-1所示。

图-1
3）根据实现思路编写、验证awk过滤语句
输出信息时，可以使用“\t”显示Tab制表位：
[root@svr5 ~]# awk -F: 'BEGIN{print "User\tUID\tHome"} \
                                {print $1 "\t"  $3  "\t"  $6}     \
                             END{print "Total",NR,"lines."}' /etc/passwd
User    UID     Home
root    0       /root
bin     1       /bin
daemon  2       /sbin
adm     3       /var/adm
lp      4       /var/spool/lpd
sync    5       /sbin
.. ..
Total 67 lines.

通道给 column -t 自动整理对齐


2 案例2：awk处理条件
2.1 问题

本案例要求使用awk工具完成下列过滤任务，注意awk处理条件的设置：
列出UID间于1~1000的用户详细信息
输出/etc/hosts文件内以127或192开头的记录
列出100以内整数中7的倍数或是含7的数
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：认识awk处理条件的设置

1）使用正则设置条件
输出其中以bash结尾的完整记录：
[root@svr5 ~]# awk -F: '/bash$/{print}' /etc/passwd
root:x:0:0:root:/root:/bin/bash
输出包含root的行数据：
[root@svr5 ~]# awk -F: '/root/' /etc/passwd
输出root或adm账户的用户名和UID信息：
[root@svr5 ~]# awk -F: '/^(root|adm)/{print $1,$3}' /etc/passwd
root 0
adm 3
输出账户名称包含root的基本信息（第1列包含root）：
[root@svr5 ~]# awk -F: '$1~/root/' /etc/passwd
输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息：
[root@svr5 ~]# awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd
root /bin/bash
sync /bin/sync
shutdown /sbin/shutdown
2）使用数值/字符串比较设置条件
比较符号：==(等于) !=（不等于） >（大于）
>=（大于等于） <（小于） <=（小于等于）
输出第3行（行号NR等于3）的用户记录：
[root@svr5 ~]# awk -F: 'NR==3{print}' /etc/passwd
输出账户UID大于等于1000的账户名称和UID信息：
[root@svr5 ~]# awk -F: '$3>=1000{print $1,$3}' /etc/passwd
tom 1000
jerry 1001
输出账户UID小于10的账户名称和UID信息：
[root@svr5 ~]# awk -F: '$3<10{print $1,$3}' /etc/passwd
root 0
bin 1
daemon 2
adm 3
lp 4
sync 5
shutdown 6
halt 7
mail 8
输出用户名为“root”的行：
[root@svr5 ~]# awk -F: '$1=="root"' /etc/passwd
root:x:0:0:root:/root:/bin/bash
3）逻辑测试条件
输出账户UID大于10并且小于20的账户信息：
[root@svr5 ~]# awk -F: '$3>10 && $3<20' /etc/passwd
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
输出账户UID大于1000或者账户UID小于10的账户信息：
[root@svr5 ~]# awk -F: '$3>1000 || $3<10' /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
varnish:x:1001:1001::/home/varnish:/sbin/nologin
nginx:x:1002:1002::/home/nginx:/sbin/nologin
4）数学运算
[root@svr5 ~]# awk 'BEGIN{x++;print x}'
1
[root@svr5 ~]# awk 'BEGIN{x=8;print x+=2}'
10
[root@svr5 ~]# awk 'BEGIN{x=8;x--;print x}'
7
[root@svr5 ~]# awk 'BEGIN{print 2+3}'
5
[root@svr5 ~]# awk 'BEGIN{print 2*3}'
6
[root@svr5 ~]# awk 'BEGIN{print 2*3}'
6
[root@svr5 ~]# awk 'BEGIN{ print 23%8}'
7
[root@svr5 ~]# seq  200 | awk  '$1%3==0{i++} END{print i}'  //统计3的倍数的数量
66
步骤二：完成任务要求的awk过滤操作

1）列出UID间于1~1000的用户详细信息：
[root@svr5 ~]# awk -F: '$3>=1 && $3<=1000' /etc/passwd
2）输出/etc/hosts映射文件内以127或者192开头的记录：
[root@svr5 ~]# awk -F: '/^(127|192)/' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
192.168.4.5  svr5.tarena.com svr5
3）列出100以内整数中7的倍数或是含7的数：
[root@svr5 ~]# seq 100 | awk '$1%7==0||$1~/7/{print}'
7
14
17
21
27
28
35
37
42
47
.. ..
3 案例3：awk综合脚本应用
3.1 问题

本案例要求编写脚本getupwd-awk.sh，实现以下需求：
找到使用bash作登录Shell的本地用户
列出这些用户的shadow密码记录
按每行“用户名 --> 密码记录”保存到getupwd.log，如图-2所示

图－2
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：任务需求及思路分析

编写getupwd-awk.sh脚本的任务要求如下：
分析出使用bash作登录Shell的本地用户
列出这些用户的shadow密码记录
按每行“用户名 -- 密码记录”保存结果
步骤二：根据实现思路编写脚本

复制原getupwd.sh脚本，生成getupwd-awk.sh：
[root@svr5 ~]# cat getupwd-awk.sh                  //确认原脚本内容

#!/bin/bash
A=`awk -F: '/bash$/{print $1}' /etc/passwd`
for i in $A
do
        grep "$i" /etc/shadow | awk -F: '{print $1,$2}' >> /tmp/getupwd.txt
done
echo "用户分析完毕，请查阅文件 /tmp/getupwd.log"         ## 完成后提示
步骤三：验证、测试脚本

[root@svr5 ~]# ./getupwd-awk.sh      
用户分析完毕，请查阅文件 /tmp/getupwd.log
[root@svr5 ~]# head -5 /tmp/getupwd.log 
root --> $6$IWgMYmRACwdbfwBo$dr8Yn983nswiJVw0dTMjzbDvSLeCd1GMYjbvsDiFEkL8jnXOLcocBQypOCr4C6BRxNowIxjh6U2qeFU0u1LST/
zengye --> $6$Qb37LOdzRl5995PI$L0zTOgnhGz8ihWkW81J.5XhPp/l7x2./Me2ag0S8tRndCBL9nIjHIKkUKulHxJ6TXyHYmffbVgUT6pbSwf8O71
clamav --> !!
mysql --> !!
.. ..
4 案例4：awk流程控制
4.1 问题

本案例要求了解awk的流程控制操作，可自行设置awk语句来有验证以下操作：
if分支结构（双分支、多分支）
练习awk数组的使用
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：awk过滤中的if分支结构

1）单分支
统计/etc/passwd文件中UID小于或等于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=1000){i++}}END{print i}' /etc/passwd
39
统计/etc/passwd文件中UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3>1000){i++}}END{print i}' /etc/passwd
8
统计/etc/passwd文件中登录Shell是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}}END{print i}'  /etc/passwd
29
2）双分支
分别统计/etc/passwd文件中UID小于或等于1000、UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=500){i++}else{j++}}END{print i,j}' /etc/passwd
39 8
分别统计/etc/passwd文件中登录Shell是“/bin/bash”、 登录Shell不是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}else{j++}} END{print i,j}' /etc/passwd
29 38
步骤二：awk数组

1）数组的语法格式
数组是一个可以存储多个值的变量，具体使用的格式如下：
定义数组的格式：数组名[下标]=元素值
调用数组的格式：数组名[下标]
遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。
[root@svr5 ~]# awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}'
88 11
[root@svr5 ~]# awk 'BEGIN{a++;print a}'
1
[root@svr5 ~]# awk 'BEGIN{a0++;print a0}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]++;print a[0]}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]=00;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'
0 0
1 11
2 22
注意，awk数组的下标除了可以使用数字，也可以使用字符串，字符串需要使用双引号：
[root@svr5 ~]# awk 'BEGIN{a["hehe"]=11;print a["hehe"]}'
11
5 案例5：awk扩展应用
5.1 问题

本案例要求使用awk工具完成下列两个任务：
分析Web日志的访问量排名，要求获得客户机的地址、访问次数，并且按照访问次数排名
5.2 方案

1）awk统计Web访问排名

ab -c 100 -n 100000 http://ip/

模拟由100个人在上网，访问网站10W次

DOS攻击 Deny of service
在分析Web日志文件时，每条访问记录的第一列就是客户机的IP地址，其中会有很多重复的IP地址。因此只用awk提取出这一列是不够的，还需要统计重复记录的数量并且进行排序。
通过awk提取信息时，利用IP地址作为数组下标，每遇到一个重复值就将此数组元素递增1，最终就获得了这个IP地址出现的次数。
针对文本排序输出可以采用sort命令，相关的常见选项为-r、-n、-k。其中-n表示按数字顺序升序排列，而-r表示反序，-k可以指定按第几个字段来排序。
5.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：统计Web访问量排名

分步测试、验证效果如下所述。
1）提取IP地址及访问量
[root@svr5 ~]# awk '{ip[$1]++} \
>  END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log
127.0.0.1 4
192.168.4.5 17
192.168.4.110 13
.. ..
2）对第1）步的结果根据访问量排名
[root@svr5 ~]# awk  '{ip[$1]++} END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log | sort -nr -k 2
192.168.4.5 17
192.168.4.110 13
127.0.0.1 4
.. ..
Top
NSD SHELL DAY07

案例1：编写一键部署软件脚本
案例2：启动脚本
案例3：编写监控脚本
案例4：编写安全检测脚本
案例5：编写进度显示脚本
1 案例1：编写一键部署软件脚本
1.1 问题

本案例要求编写脚本实现一键部署Nginx软件（Web服务器）：
一键源码安装Nginx软件
脚本自动安装相关软件的依赖包
脚本自动判断yum是否可用
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备工作

1）判断yum源是否可用
通过yum repolist查看软件包数量是否大于0：
[root@svr5 ~]# yum repolist 
[root@svr5 ~]# yum repolist | awk '/repolist/{print $2}' 
[root@svr5 ~]# yum repolist | awk '/repolist/{print $2}' |sed 's/,//'
[root@svr5 ~]# N=$(yum repolist | awk '/repolist/{print $2}' |sed 's/,//')
[root@svr5 ~]# [ $N –le 0 ] && echo 'yum 不可用'
2）依赖包
源码安装Nginx需要提前安装依赖包软件gcc,openssl-devel,pcre-devel
步骤二：编写脚本

1）参考脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
N=$(yum repolist | awk '/repolist/{print $2}' | sed 's/,//')
if [ $N -le 0 ];then
    echo "yum 不可用"
    exit
fi
yum -y install gcc openssl-devel pcre-devel
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make
make install
2）确认安装效果
Nginx默认安装路径为/usr/local/nginx,该目录下会提供4个子目录，分别如下：
/usr/local/nginx/conf	配置文件目录
/usr/local/nginx/html	网站页面目录
/usr/local/nginx/logs	Nginx日志目录
/usr/local/nginx/sbin	主程序目录
主程序命令参数：
[root@svr5 ~]# /usr/local/nginx/sbin/nginx                //启动服务
[root@svr5 ~]# /usr/local/nginx/sbin/nginx    -s stop        //关闭服务
[root@svr5 ~]# /usr/local/nginx/sbin/nginx    -V            //查看软件信息

启动服务时，报错，80端口被占用，需要关闭httpd服务

2 案例2：启动脚本
2.1 问题

本案例要求编写Ngin启动脚本，要求如下：
脚本支持start、stop、restart、status
脚本支持报错提示
脚本具有判断是否已经开启或关闭的功能
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写脚本

脚本通过位置变量$1读取用户的操作指令，判断是start、stop、restart还是status。
1）参考脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
#!/bin/bash
case $1 in
start)
        /usr/local/nginx/sbin/nginx;;
stop)
        /usr/local/nginx/sbin/nginx -s stop;;
restart)
        /usr/local/nginx/sbin/nginx -s stop
        /usr/local/nignx/sbin/nginx;;
status)
	netstat -ntulp |grep -q nginx
	if [ $? -eq 0 ];then
	echo 服务已启动, Active: active (running)
	else
	echo 服务未启动，Active: inactive (dead)
	fi;;
*)
        echo Error;;
esac


# netstat   -anptul  |  grep  nginx
选项含义：
-a，所有连接
-n，以数字方式显示地址和端口
-p，列出对应的进程和PID
-t，列出TCP类型的连接
-u，列出UDP类型的连接
-l，仅显示listen的端口

2）执行测试脚本：
[root@svr5 ~]# ./test.sh start
[root@svr5 ~]# ./test.sh stop
[root@svr5 ~]# ./test.sh status
[root@svr5 ~]# ./test.sh xyz
3 案例3：编写监控脚本
3.1 问题

本案例要求编写脚本，实现计算机各个性能数据监控的功能，具体监控项目要求如下：
CPU负载
网卡流量
内存剩余容量
磁盘剩余容量
计算机账户数量
当前登录账户数量
计算机当前开启的进程数量
本机已安装的软件包数量
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备工作

1）查看性能数据的命令
[root@svr5 ~]# uptime                            //查看CPU负载
[root@svr5 ~]# ifconfig eth0                    //查看网卡流量
[root@svr5 ~]# free                            //查看内存信息
[root@svr5 ~]# df                                //查看磁盘空间
[root@svr5 ~]# wc –l /etc/passwd                //查看计算机账户数量
[root@svr5 ~]# who |wc –l                        //查看登录账户数量
[root@svr5 ~]# rpm –qa |wc -l                    //查看已安装软件包数量
步骤二：编写参考脚本

1）脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
ip=`ifconfig eth0 | awk '/inet /{print $2}'`
echo "本地IP地址是:"$ip
cpu=`uptime | awk '{print $10}'`
echo "本机CPU最近5分钟的负载是:"$cpu
net_in=`ifconfig eth0 | awk '/RX p/{print $5}'`
echo "入站网卡流量为:"$net_in
net_out=`ifconfig eth0 | awk '/TX p/{print $5}'`
echo "出站网卡流量为:"$net_out
mem=`free | awk '/Mem/{print $4}'`
echo "内存剩余容量为:"$mem
disk=`df | awk '/\/$/{print $4}'`
echo "根分区剩余容量为:"$disk
user=`cat /etc/passwd |wc -l`
echo "本地账户数量为:"$user
login=`who | wc -l`
echo "当前登陆计算机的账户数量为:"$login
process=`ps aux | wc -l`
echo "当前计算机启动的进程数量为:"$process
soft=`rpm -qa | wc -l`
echo "当前计算机已安装的软件数量为:"$soft
4 案例4：编写安全检测脚本
4.1 问题

本案例要求编写脚本，防止远程ssh暴力破解密码，具体监控项目要求如下：
检测ssh登录日志，如果远程登陆账号名错误3次，则屏蔽远程主机的IP
检测ssh登录日志，如果远程登陆密码错误3次，则屏蔽远程主机的IP
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备工作

1）过滤帐户名失败的命令(登陆日志文件为/var/log/secure)
[root@svr5 ~]# awk '/Invalid user/{print $10}' /var/log/secure
2）过滤密码失败的命令
[root@svr5 ~]# awk '/Failed password/{print $11}' /var/log/secure
步骤二：编写参考脚本

1）脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
awk '/Failed password/{print $11}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
awk '/Invalid user/{print $10}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
5 案例5：编写进度显示脚本
5.1 问题

本案例要求编写脚本，实现带进程显示的复制脚本，具体要求如下：
默认Linux的cp命令不具有进度显示
我们需要自己编写脚本实现进度显示
可以使用进度条的方式，或者显示百分比的方式
5.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写参考脚本

1）脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
jindu(){
while :
do
    echo -ne '\033[43m \033[0m'
        sleep 0.3
done
}
jindu &
cp -r  $1  $2
kill $!     #####     $!显示最后一个放入后台进程的进程号

